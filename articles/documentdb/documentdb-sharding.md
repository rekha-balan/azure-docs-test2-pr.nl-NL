---
redirect_url: https://azure.microsoft.com/services/documentdb/
ROBOTS: NOINDEX, NOFOLLOW
ms.openlocfilehash: c1676b25073a088e638d73d9ef0413ee10f519f7
ms.sourcegitcommit: 5b9d839c0c0a94b293fdafe1d6e5429506c07e05
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 08/02/2018
ms.locfileid: "44553463"
---
# <a name="how-to-partition-data-using-client-side-support-in-documentdb"></a><span data-ttu-id="2c6ce-101">How to partition data using client-side support in DocumentDB</span><span class="sxs-lookup"><span data-stu-id="2c6ce-101">How to partition data using client-side support in DocumentDB</span></span>
<span data-ttu-id="2c6ce-102">Azure DocumentDB supports [automatic partitioning of collections](documentdb-partition-data.md).</span><span class="sxs-lookup"><span data-stu-id="2c6ce-102">Azure DocumentDB supports [automatic partitioning of collections](documentdb-partition-data.md).</span></span> <span data-ttu-id="2c6ce-103">However, there are use cases where it is beneficial to have fine grained control over partitioning behavior.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-103">However, there are use cases where it is beneficial to have fine grained control over partitioning behavior.</span></span> <span data-ttu-id="2c6ce-104">In order to reduce the boiler-plate code required for partitioning tasks, we have added functionality in the .NET, Node.js, and Java SDKs that makes it easier to build applications that are scaled out across multiple collections.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-104">In order to reduce the boiler-plate code required for partitioning tasks, we have added functionality in the .NET, Node.js, and Java SDKs that makes it easier to build applications that are scaled out across multiple collections.</span></span>

<span data-ttu-id="2c6ce-105">In this article, we'll take a look at the classes and interfaces in the .NET SDK and how you can use them to develop partitioned applications.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-105">In this article, we'll take a look at the classes and interfaces in the .NET SDK and how you can use them to develop partitioned applications.</span></span> <span data-ttu-id="2c6ce-106">Other SDKs like Java, Node.js and Python support similar methods and interfaces for client-side partitioning.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-106">Other SDKs like Java, Node.js and Python support similar methods and interfaces for client-side partitioning.</span></span>

## <a name="client-side-partitioning-with-the-documentdb-sdk"></a><span data-ttu-id="2c6ce-107">Client-side Partitioning with the DocumentDB SDK</span><span class="sxs-lookup"><span data-stu-id="2c6ce-107">Client-side Partitioning with the DocumentDB SDK</span></span>
<span data-ttu-id="2c6ce-108">Before we dig deeper into partitioning, let's recap some basic DocumentDB concepts that relate to partitioning.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-108">Before we dig deeper into partitioning, let's recap some basic DocumentDB concepts that relate to partitioning.</span></span> <span data-ttu-id="2c6ce-109">Every Azure DocumentDB database account consists of a set of databases, each containing multiple collections, each of which can contain stored procedures, triggers, UDFs, documents, and related attachments.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-109">Every Azure DocumentDB database account consists of a set of databases, each containing multiple collections, each of which can contain stored procedures, triggers, UDFs, documents, and related attachments.</span></span> <span data-ttu-id="2c6ce-110">Collections can be single-partition or partitioned themselves and have the following properties:</span><span class="sxs-lookup"><span data-stu-id="2c6ce-110">Collections can be single-partition or partitioned themselves and have the following properties:</span></span>

* <span data-ttu-id="2c6ce-111">Collections offer performance isolation.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-111">Collections offer performance isolation.</span></span> <span data-ttu-id="2c6ce-112">Hence there is a performance benefit in collating similar documents within the same collection.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-112">Hence there is a performance benefit in collating similar documents within the same collection.</span></span> <span data-ttu-id="2c6ce-113">For example, for time series data, you might want to place data for the last month, that is frequently queried, within a collection with higher provisioned throughput whereas older data is placed within collections with low provisioned throughput.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-113">For example, for time series data, you might want to place data for the last month, that is frequently queried, within a collection with higher provisioned throughput whereas older data is placed within collections with low provisioned throughput.</span></span>
* <span data-ttu-id="2c6ce-114">ACID transactions i.e. stored procedures and triggers cannot span a collection.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-114">ACID transactions i.e. stored procedures and triggers cannot span a collection.</span></span> <span data-ttu-id="2c6ce-115">Transactions are scoped within a single partition key value within a collection.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-115">Transactions are scoped within a single partition key value within a collection.</span></span>
* <span data-ttu-id="2c6ce-116">Collections do not enforce a schema, so they can be used for JSON documents of the same type or different types.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-116">Collections do not enforce a schema, so they can be used for JSON documents of the same type or different types.</span></span>

<span data-ttu-id="2c6ce-117">Starting with version [1.5.x of the Azure DocumentDB SDKs](documentdb-sdk-dotnet.md), you can perform document operations directly against a database.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-117">Starting with version [1.5.x of the Azure DocumentDB SDKs](documentdb-sdk-dotnet.md), you can perform document operations directly against a database.</span></span> <span data-ttu-id="2c6ce-118">Internally the [DocumentClient](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.documentclient.aspx) uses the PartitionResolver that you have specified for the database to route requests to the appropriate collection.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-118">Internally the [DocumentClient](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.documentclient.aspx) uses the PartitionResolver that you have specified for the database to route requests to the appropriate collection.</span></span>

> [!NOTE]
> <span data-ttu-id="2c6ce-119">[Server-side partitioning](documentdb-partition-data.md) introduced in REST API 2015-12-16 and SDKs 1.6.0+ deprecates the client-side partition resolver approach for simple use cases.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-119">[Server-side partitioning](documentdb-partition-data.md) introduced in REST API 2015-12-16 and SDKs 1.6.0+ deprecates the client-side partition resolver approach for simple use cases.</span></span> <span data-ttu-id="2c6ce-120">Client-side partitioning however is more flexible and lets you control performance isolation across partition keys, control degree of parallelism while reading results from multiple partitions, and use range/spatial partitioning approaches vs. hash.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-120">Client-side partitioning however is more flexible and lets you control performance isolation across partition keys, control degree of parallelism while reading results from multiple partitions, and use range/spatial partitioning approaches vs. hash.</span></span>
> 
> 

<span data-ttu-id="2c6ce-121">For example, in .NET, each PartitionResolver class is a concrete implementation of an [IPartitionResolver](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.aspx) interface that has three methods - [GetPartitionKey](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.getpartitionkey.aspx), [ResolveForCreate](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.resolveforcreate.aspx) and [ResolveForRead](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.resolveforread.aspx).</span><span class="sxs-lookup"><span data-stu-id="2c6ce-121">For example, in .NET, each PartitionResolver class is a concrete implementation of an [IPartitionResolver](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.aspx) interface that has three methods - [GetPartitionKey](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.getpartitionkey.aspx), [ResolveForCreate](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.resolveforcreate.aspx) and [ResolveForRead](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.ipartitionresolver.resolveforread.aspx).</span></span> <span data-ttu-id="2c6ce-122">LINQ queries and ReadFeed iterators use the ResolveForRead method internally to iterate over all the collections that match the partition key for the request.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-122">LINQ queries and ReadFeed iterators use the ResolveForRead method internally to iterate over all the collections that match the partition key for the request.</span></span> <span data-ttu-id="2c6ce-123">Similarly, create operations use the ResolveForCreate method to route creates to the right partition.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-123">Similarly, create operations use the ResolveForCreate method to route creates to the right partition.</span></span> <span data-ttu-id="2c6ce-124">There are no changes required for Replace, Delete and Read since they use documents, which already contain the reference to the corresponding collection.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-124">There are no changes required for Replace, Delete and Read since they use documents, which already contain the reference to the corresponding collection.</span></span>

<span data-ttu-id="2c6ce-125">The SDKs also includes two classes that support the two canonical partitioning techniques, hashing and range lookups, via a [HashPartitionResolver](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx) and a [RangePartitionResolver](https://msdn.microsoft.com/library/azure/mt126047.aspx).</span><span class="sxs-lookup"><span data-stu-id="2c6ce-125">The SDKs also includes two classes that support the two canonical partitioning techniques, hashing and range lookups, via a [HashPartitionResolver](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx) and a [RangePartitionResolver](https://msdn.microsoft.com/library/azure/mt126047.aspx).</span></span> <span data-ttu-id="2c6ce-126">You can use these classes to easily add partitioning logic to your application.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-126">You can use these classes to easily add partitioning logic to your application.</span></span>  

## <a name="add-partitioning-logic-and-register-the-partitionresolver"></a><span data-ttu-id="2c6ce-127">Add partitioning logic and register the PartitionResolver</span><span class="sxs-lookup"><span data-stu-id="2c6ce-127">Add partitioning logic and register the PartitionResolver</span></span>
<span data-ttu-id="2c6ce-128">Here's a snippet showing how to create a [HashPartitionResolver](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx) and register with the DocumentClient for a database.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-128">Here's a snippet showing how to create a [HashPartitionResolver](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx) and register with the DocumentClient for a database.</span></span>

```cs
// Create some collections to partition data.
DocumentCollection collection1 = await client.CreateDocumentCollectionAsync(...);
DocumentCollection collection2 = await client.CreateDocumentCollectionAsync(...);

// Initialize a HashPartitionResolver using the "UserId" property and the two collection self-links.
HashPartitionResolver hashResolver = new HashPartitionResolver(
    u => ((UserProfile)u).UserId, 
    new string[] { collection1.SelfLink, collection2.SelfLink });

// Register the PartitionResolver with the database.
this.client.PartitionResolvers[database.SelfLink] = hashResolver;

```

## <a name="create-documents-in-a-partition"></a><span data-ttu-id="2c6ce-129">Create documents in a partition</span><span class="sxs-lookup"><span data-stu-id="2c6ce-129">Create documents in a partition</span></span>
<span data-ttu-id="2c6ce-130">Once the PartitionResolver is registered, you can perform creates and queries directly against the database as shown below.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-130">Once the PartitionResolver is registered, you can perform creates and queries directly against the database as shown below.</span></span> <span data-ttu-id="2c6ce-131">In this example, the SDK uses the PartitionResolver to extract the UserId, hash it, and then use that value to route the create operation to the correct collection.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-131">In this example, the SDK uses the PartitionResolver to extract the UserId, hash it, and then use that value to route the create operation to the correct collection.</span></span>

```cs
Document johnDocument = await this.client.CreateDocumentAsync(
    database.SelfLink, new UserProfile("J1", "@John", Region.UnitedStatesEast));
Document ryanDocument = await this.client.CreateDocumentAsync(
    database.SelfLink, new UserProfile("U4", "@Ryan", Region.AsiaPacific, UserStatus.AppearAway));
```

## <a name="create-queries-against-partitions"></a><span data-ttu-id="2c6ce-132">Create queries against partitions</span><span class="sxs-lookup"><span data-stu-id="2c6ce-132">Create queries against partitions</span></span>
<span data-ttu-id="2c6ce-133">You can query using the [CreateDocumentQuery](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.linq.documentqueryable.createdocumentquery.aspx) method by passing in the database and a partition key.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-133">You can query using the [CreateDocumentQuery](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.linq.documentqueryable.createdocumentquery.aspx) method by passing in the database and a partition key.</span></span> <span data-ttu-id="2c6ce-134">The query returns a single result-set over all the collections within the database that map to the partition key.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-134">The query returns a single result-set over all the collections within the database that map to the partition key.</span></span>  

```cs
// Query for John's document by ID - uses PartitionResolver to restrict the query to the partitions 
// containing @John. Again the query uses the database self link, and relies on the hash resolver 
// to route the appropriate collection.
var query = this.client.CreateDocumentQuery<UserProfile>(
    database.SelfLink, null, partitionResolver.GetPartitionKey(johnProfile))
    .Where(u => u.UserName == "@John");
johnProfile = query.AsEnumerable().FirstOrDefault();
```

## <a name="create-queries-against-all-collections-in-the-database"></a><span data-ttu-id="2c6ce-135">Create queries against all collections in the database</span><span class="sxs-lookup"><span data-stu-id="2c6ce-135">Create queries against all collections in the database</span></span>
<span data-ttu-id="2c6ce-136">You can also query all collections within the database and enumerate the results as show below, by skipping the partition key argument.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-136">You can also query all collections within the database and enumerate the results as show below, by skipping the partition key argument.</span></span>

```cs
// Query for all "Available" users. Here since there is no partition key, the query is serially executed 
// across each partition/collection and returns a single result-set. 
query = this.client.CreateDocumentQuery<UserProfile>(database.SelfLink)
    .Where(u => u.Status == UserStatus.Available);
foreach (UserProfile activeUser in query)
{
    Console.WriteLine(activeUser);
}
```

## <a name="hash-partition-resolver"></a><span data-ttu-id="2c6ce-137">Hash Partition Resolver</span><span class="sxs-lookup"><span data-stu-id="2c6ce-137">Hash Partition Resolver</span></span>
<span data-ttu-id="2c6ce-138">With hash partitioning, partitions are assigned based on the value of a hash function, allowing you to evenly distribute requests and data across a number of partitions.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-138">With hash partitioning, partitions are assigned based on the value of a hash function, allowing you to evenly distribute requests and data across a number of partitions.</span></span> <span data-ttu-id="2c6ce-139">This approach is commonly used to partition data produced or consumed from a large number of distinct clients, and is useful for storing user profiles, catalog items, and IoT ("Internet of Things") telemetry data.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-139">This approach is commonly used to partition data produced or consumed from a large number of distinct clients, and is useful for storing user profiles, catalog items, and IoT ("Internet of Things") telemetry data.</span></span> <span data-ttu-id="2c6ce-140">Hash partitioning is also used by DocumentDB's server-side partitioning support within a collection.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-140">Hash partitioning is also used by DocumentDB's server-side partitioning support within a collection.</span></span>

<span data-ttu-id="2c6ce-141">**Hash Partitioning:**
![Diagram illustrating how hash partitioning evenly distributes requests across partitions](https://docstestmedia1.blob.core.windows.net/azure-media/articles/documentdb/media/documentdb-sharding/partition-hash.png)</span><span class="sxs-lookup"><span data-stu-id="2c6ce-141">**Hash Partitioning:**
![Diagram illustrating how hash partitioning evenly distributes requests across partitions](https://docstestmedia1.blob.core.windows.net/azure-media/articles/documentdb/media/documentdb-sharding/partition-hash.png)</span></span>

<span data-ttu-id="2c6ce-142">A simple hash partitioning scheme across *N* collections would be to take any document, compute *hash(d) mod N* to determine which collection it's placed in.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-142">A simple hash partitioning scheme across *N* collections would be to take any document, compute *hash(d) mod N* to determine which collection it's placed in.</span></span> <span data-ttu-id="2c6ce-143">But a problem with this simple technique is that it does not work well when you add new collections, or remove collections as this would require almost all the data to get reshuffled.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-143">But a problem with this simple technique is that it does not work well when you add new collections, or remove collections as this would require almost all the data to get reshuffled.</span></span> <span data-ttu-id="2c6ce-144">[Consistent hashing](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.23.3738) is a well-known algorithm that addresses this by implementing a hashing scheme that minimizes the amount of data movement required during adding or removing collections.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-144">[Consistent hashing](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.23.3738) is a well-known algorithm that addresses this by implementing a hashing scheme that minimizes the amount of data movement required during adding or removing collections.</span></span>

<span data-ttu-id="2c6ce-145">The [HashPartitionResolver](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx) class implements logic to build a consistent hash ring over the hash function specified in the [IHashGenerator](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.ihashgenerator.aspx) interface.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-145">The [HashPartitionResolver](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.hashpartitionresolver.aspx) class implements logic to build a consistent hash ring over the hash function specified in the [IHashGenerator](https://msdn.microsoft.com/library/azure/microsoft.azure.documents.partitioning.ihashgenerator.aspx) interface.</span></span> <span data-ttu-id="2c6ce-146">By default, the HashPartitionResolver uses an MD5 hash function, but you can swap this out with your own hashing implementation.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-146">By default, the HashPartitionResolver uses an MD5 hash function, but you can swap this out with your own hashing implementation.</span></span> <span data-ttu-id="2c6ce-147">The HashPartitionResolver internally creates 16 hashes or "virtual nodes" within the hash ring for each collection in order to achieve a more uniform distribution of documents across the collections, but you can vary this number to trade off data skewness with the amount of client side computation.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-147">The HashPartitionResolver internally creates 16 hashes or "virtual nodes" within the hash ring for each collection in order to achieve a more uniform distribution of documents across the collections, but you can vary this number to trade off data skewness with the amount of client side computation.</span></span>

<span data-ttu-id="2c6ce-148">**Consistent hashing with HashPartitionResolver:**
![Diagram illustrating how HashPartitionResolver creates a hash ring](https://docstestmedia1.blob.core.windows.net/azure-media/articles/documentdb/media/documentdb-sharding/HashPartitionResolver.JPG)</span><span class="sxs-lookup"><span data-stu-id="2c6ce-148">**Consistent hashing with HashPartitionResolver:**
![Diagram illustrating how HashPartitionResolver creates a hash ring](https://docstestmedia1.blob.core.windows.net/azure-media/articles/documentdb/media/documentdb-sharding/HashPartitionResolver.JPG)</span></span>

## <a name="range-partition-resolver"></a><span data-ttu-id="2c6ce-149">Range Partition Resolver</span><span class="sxs-lookup"><span data-stu-id="2c6ce-149">Range Partition Resolver</span></span>
<span data-ttu-id="2c6ce-150">In range partitioning, partitions are assigned based on whether the partition key is within a certain range.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-150">In range partitioning, partitions are assigned based on whether the partition key is within a certain range.</span></span> <span data-ttu-id="2c6ce-151">This is commonly used for partitioning with time stamp properties (e.g., eventTime between Apr 1, 2015 and Apr 14, 2015).</span><span class="sxs-lookup"><span data-stu-id="2c6ce-151">This is commonly used for partitioning with time stamp properties (e.g., eventTime between Apr 1, 2015 and Apr 14, 2015).</span></span> <span data-ttu-id="2c6ce-152">The [RangePartitionResolver](https://msdn.microsoft.com/library/azure/mt126047.aspx) class helps you maintain a mapping between a Range\<T\> and collection self-link.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-152">The [RangePartitionResolver](https://msdn.microsoft.com/library/azure/mt126047.aspx) class helps you maintain a mapping between a Range\<T\> and collection self-link.</span></span> 

<span data-ttu-id="2c6ce-153">[Range\<T\>](https://msdn.microsoft.com/library/azure/mt126048.aspx) is a simple class that manages ranges of any types that implement IComparable\<T\> and IEquatable\<T\> like strings or numbers.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-153">[Range\<T\>](https://msdn.microsoft.com/library/azure/mt126048.aspx) is a simple class that manages ranges of any types that implement IComparable\<T\> and IEquatable\<T\> like strings or numbers.</span></span> <span data-ttu-id="2c6ce-154">For reads and creates, you can pass in any arbitrary range, and the resolver identifies all the candidate collections by identifying the ranges of the partitions that intersect with the requested range.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-154">For reads and creates, you can pass in any arbitrary range, and the resolver identifies all the candidate collections by identifying the ranges of the partitions that intersect with the requested range.</span></span> <span data-ttu-id="2c6ce-155">This functionality can be useful when performing range queries against time series data.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-155">This functionality can be useful when performing range queries against time series data.</span></span>

<span data-ttu-id="2c6ce-156">**Range Partitioning:**</span><span class="sxs-lookup"><span data-stu-id="2c6ce-156">**Range Partitioning:**</span></span>  

![ <span data-ttu-id="2c6ce-157">Diagram illustrating how range partitioning evenly distributes requests across partitions</span><span class="sxs-lookup"><span data-stu-id="2c6ce-157">Diagram illustrating how range partitioning evenly distributes requests across partitions</span></span>](https://docstestmedia1.blob.core.windows.net/azure-media/articles/documentdb/media/documentdb-sharding/partition-range.png)  

<span data-ttu-id="2c6ce-158">A special case of range partitioning is when the range is just a single discrete value, sometimes called "lookup partitioning".</span><span class="sxs-lookup"><span data-stu-id="2c6ce-158">A special case of range partitioning is when the range is just a single discrete value, sometimes called "lookup partitioning".</span></span> <span data-ttu-id="2c6ce-159">This is commonly used for partitioning by region (e.g. the partition for Scandinavia contains Norway, Denmark, and Sweden) or for partitioning tenants in a multi-tenant application.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-159">This is commonly used for partitioning by region (e.g. the partition for Scandinavia contains Norway, Denmark, and Sweden) or for partitioning tenants in a multi-tenant application.</span></span>

## <a name="samples"></a><span data-ttu-id="2c6ce-160">Samples</span><span class="sxs-lookup"><span data-stu-id="2c6ce-160">Samples</span></span>
<span data-ttu-id="2c6ce-161">Take a look at the  [DocumentDB Partitioning Samples GitHub project](https://github.com/Azure/azure-documentdb-dotnet/tree/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning) containing code snippets on how to use these PartitionResolvers and extend them to implement your own resolvers to fit specific use cases, like the following:</span><span class="sxs-lookup"><span data-stu-id="2c6ce-161">Take a look at the  [DocumentDB Partitioning Samples GitHub project](https://github.com/Azure/azure-documentdb-dotnet/tree/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning) containing code snippets on how to use these PartitionResolvers and extend them to implement your own resolvers to fit specific use cases, like the following:</span></span> 

* <span data-ttu-id="2c6ce-162">How to specify an arbitrary lambda expression for GetPartitionKey and use it to implement compound partitioning keys or to partition different types of objects differently.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-162">How to specify an arbitrary lambda expression for GetPartitionKey and use it to implement compound partitioning keys or to partition different types of objects differently.</span></span>
* <span data-ttu-id="2c6ce-163">How to create a simple [LookupPartitionResolver](https://github.com/Azure/azure-documentdb-dotnet/blob/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning/Partitioners/LookupPartitionResolver.cs) that uses a manual lookup table to perform partitioning.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-163">How to create a simple [LookupPartitionResolver](https://github.com/Azure/azure-documentdb-dotnet/blob/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning/Partitioners/LookupPartitionResolver.cs) that uses a manual lookup table to perform partitioning.</span></span> <span data-ttu-id="2c6ce-164">This pattern is commonly used for partitioning based on discrete values like region, tenant ID or application name.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-164">This pattern is commonly used for partitioning based on discrete values like region, tenant ID or application name.</span></span>
* <span data-ttu-id="2c6ce-165">How to create a [ManagedPartitionResolver](https://github.com/Azure/azure-documentdb-dotnet/blob/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning/Partitioners/ManagedHashPartitionResolver.cs) that creates collections automatically based on a template that defines a naming scheme, IndexingPolicy and stored procedures that need to be registered against new collections.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-165">How to create a [ManagedPartitionResolver](https://github.com/Azure/azure-documentdb-dotnet/blob/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning/Partitioners/ManagedHashPartitionResolver.cs) that creates collections automatically based on a template that defines a naming scheme, IndexingPolicy and stored procedures that need to be registered against new collections.</span></span>
* <span data-ttu-id="2c6ce-166">How to create a scheme-less [SpilloverPartitionResolver](https://github.com/Azure/azure-documentdb-dotnet/blob/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning/Partitioners/SpilloverPartitionResolver.cs) that simply creates new collections as the old collections fill up.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-166">How to create a scheme-less [SpilloverPartitionResolver](https://github.com/Azure/azure-documentdb-dotnet/blob/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning/Partitioners/SpilloverPartitionResolver.cs) that simply creates new collections as the old collections fill up.</span></span>
* <span data-ttu-id="2c6ce-167">How to serialize and deserialize your PartitionResolver state as JSON, so that you can share between processes and across shutdowns.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-167">How to serialize and deserialize your PartitionResolver state as JSON, so that you can share between processes and across shutdowns.</span></span> <span data-ttu-id="2c6ce-168">You can persist these in config files, or even in a DocumentDB collection.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-168">You can persist these in config files, or even in a DocumentDB collection.</span></span>
* <span data-ttu-id="2c6ce-169">A [DocumentClientHashPartitioningManager](https://github.com/Azure/azure-documentdb-dotnet/blob/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning/Util/DocumentClientHashPartitioningManager.cs) class for dynamically adding and removing partitions to a database partitioned based on consistent hashing.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-169">A [DocumentClientHashPartitioningManager](https://github.com/Azure/azure-documentdb-dotnet/blob/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning/Util/DocumentClientHashPartitioningManager.cs) class for dynamically adding and removing partitions to a database partitioned based on consistent hashing.</span></span> <span data-ttu-id="2c6ce-170">Internally it uses a [TransitionHashPartitionResolver](https://github.com/Azure/azure-documentdb-dotnet/blob/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning/Partitioners/TransitionHashPartitionResolver.cs) to route reads and writes during migration using one of four modes - read from the old partitioning scheme (ReadCurrent), the new one (ReadNext), merge results from both (ReadBoth) or be unavailable during migration (None).</span><span class="sxs-lookup"><span data-stu-id="2c6ce-170">Internally it uses a [TransitionHashPartitionResolver](https://github.com/Azure/azure-documentdb-dotnet/blob/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning/Partitioners/TransitionHashPartitionResolver.cs) to route reads and writes during migration using one of four modes - read from the old partitioning scheme (ReadCurrent), the new one (ReadNext), merge results from both (ReadBoth) or be unavailable during migration (None).</span></span>

<span data-ttu-id="2c6ce-171">The samples are open source and we encourage you to submit pull requests with contributions that could benefit other DocumentDB developers.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-171">The samples are open source and we encourage you to submit pull requests with contributions that could benefit other DocumentDB developers.</span></span> <span data-ttu-id="2c6ce-172">Please refer to the [Contribution guidelines](https://github.com/Azure/azure-documentdb-net/blob/master/Contributing.md) for guidance on how to contribute.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-172">Please refer to the [Contribution guidelines](https://github.com/Azure/azure-documentdb-net/blob/master/Contributing.md) for guidance on how to contribute.</span></span>  

> [!NOTE]
> <span data-ttu-id="2c6ce-173">Collection creates are rate-limited by DocumentDB, so some of the sample methods shown here might take a few minutes to complete.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-173">Collection creates are rate-limited by DocumentDB, so some of the sample methods shown here might take a few minutes to complete.</span></span>
> 
> 

## <a name="faq"></a><span data-ttu-id="2c6ce-174">FAQ</span><span class="sxs-lookup"><span data-stu-id="2c6ce-174">FAQ</span></span>
<span data-ttu-id="2c6ce-175">**Does DocumentDB support server-side partitioning?**</span><span class="sxs-lookup"><span data-stu-id="2c6ce-175">**Does DocumentDB support server-side partitioning?**</span></span>

<span data-ttu-id="2c6ce-176">Yes, DocumentDB supports [server-side partitioning](documentdb-partition-data.md).</span><span class="sxs-lookup"><span data-stu-id="2c6ce-176">Yes, DocumentDB supports [server-side partitioning](documentdb-partition-data.md).</span></span> <span data-ttu-id="2c6ce-177">DocumentDB also supports client-side partitioning via client-side partition resolvers for more advanced use cases.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-177">DocumentDB also supports client-side partitioning via client-side partition resolvers for more advanced use cases.</span></span>

<span data-ttu-id="2c6ce-178">**When should I use server-side vs. client-side partitioning?**</span><span class="sxs-lookup"><span data-stu-id="2c6ce-178">**When should I use server-side vs. client-side partitioning?**</span></span>
<span data-ttu-id="2c6ce-179">For the majority of use cases, we recommend the use of server-side partitioning since it handles the administrative tasks of partitioning data and routing requests.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-179">For the majority of use cases, we recommend the use of server-side partitioning since it handles the administrative tasks of partitioning data and routing requests.</span></span> <span data-ttu-id="2c6ce-180">However, if you need range partitioning or have a specialized use case for performance isolation between different values of partition keys, then client-side partitioning might be the best approach.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-180">However, if you need range partitioning or have a specialized use case for performance isolation between different values of partition keys, then client-side partitioning might be the best approach.</span></span>

<span data-ttu-id="2c6ce-181">**How do I add or remove a collection to my partitioning scheme?**</span><span class="sxs-lookup"><span data-stu-id="2c6ce-181">**How do I add or remove a collection to my partitioning scheme?**</span></span>

<span data-ttu-id="2c6ce-182">Take a look at the implementation of DocumentClientHashPartitioningManager in the samples project for an example of how you can implement repartitioning.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-182">Take a look at the implementation of DocumentClientHashPartitioningManager in the samples project for an example of how you can implement repartitioning.</span></span>

<span data-ttu-id="2c6ce-183">**How do I persist or share my partitioning configuration with other clients?**</span><span class="sxs-lookup"><span data-stu-id="2c6ce-183">**How do I persist or share my partitioning configuration with other clients?**</span></span>

<span data-ttu-id="2c6ce-184">You can serialize the partitioner state as JSON and store in configuration files, or even within DocumentDB collections.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-184">You can serialize the partitioner state as JSON and store in configuration files, or even within DocumentDB collections.</span></span> <span data-ttu-id="2c6ce-185">Take a look at the RunSerializeDeserializeSample method in the samples project for an example.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-185">Take a look at the RunSerializeDeserializeSample method in the samples project for an example.</span></span>

<span data-ttu-id="2c6ce-186">**How do I chain various partitioning techniques?**</span><span class="sxs-lookup"><span data-stu-id="2c6ce-186">**How do I chain various partitioning techniques?**</span></span>

<span data-ttu-id="2c6ce-187">You can chain PartitionResolvers by implementing your own IPartitionResolver that internally uses one or more existing resolvers.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-187">You can chain PartitionResolvers by implementing your own IPartitionResolver that internally uses one or more existing resolvers.</span></span> <span data-ttu-id="2c6ce-188">Take a look at TransitionHashPartitionResolver in the samples project for an example.</span><span class="sxs-lookup"><span data-stu-id="2c6ce-188">Take a look at TransitionHashPartitionResolver in the samples project for an example.</span></span>

## <a name="references"></a><span data-ttu-id="2c6ce-189">References</span><span class="sxs-lookup"><span data-stu-id="2c6ce-189">References</span></span>
* [<span data-ttu-id="2c6ce-190">Server-side Partitioning in DocumentDB</span><span class="sxs-lookup"><span data-stu-id="2c6ce-190">Server-side Partitioning in DocumentDB</span></span>](documentdb-partition-data.md)
* [<span data-ttu-id="2c6ce-191">DocumentDB collections and performance levels</span><span class="sxs-lookup"><span data-stu-id="2c6ce-191">DocumentDB collections and performance levels</span></span>](documentdb-performance-levels.md)
* [<span data-ttu-id="2c6ce-192">Partitioning code samples on GitHub</span><span class="sxs-lookup"><span data-stu-id="2c6ce-192">Partitioning code samples on GitHub</span></span>](https://github.com/Azure/azure-documentdb-dotnet/tree/287acafef76ad223577759b0170c8f08adb45755/samples/code-samples/Partitioning)
* [<span data-ttu-id="2c6ce-193">DocumentDB .NET SDK Documentation at MSDN</span><span class="sxs-lookup"><span data-stu-id="2c6ce-193">DocumentDB .NET SDK Documentation at MSDN</span></span>](https://msdn.microsoft.com/library/azure/dn948556.aspx)
* [<span data-ttu-id="2c6ce-194">DocumentDB .NET samples</span><span class="sxs-lookup"><span data-stu-id="2c6ce-194">DocumentDB .NET samples</span></span>](https://github.com/Azure/azure-documentdb-net)
* [<span data-ttu-id="2c6ce-195">DocumentDB Blog on Performance Tips</span><span class="sxs-lookup"><span data-stu-id="2c6ce-195">DocumentDB Blog on Performance Tips</span></span>](https://azure.microsoft.com/blog/2015/01/20/performance-tips-for-azure-documentdb-part-1-2/)




