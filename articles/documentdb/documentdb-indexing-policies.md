---
title: DocumentDB Indexing Policies | Microsoft Docs
description: Understand how indexing works in DocumentDB learn how to configure and change the indexing policy. Configure the indexing policy withing DocumentDB for automatic indexing and greater performance.
keywords: how indexing works, automatic indexing, indexing database, documentdb, azure, Microsoft azure
services: documentdb
documentationcenter: ''
author: arramac
manager: jhubbard
editor: monicar
ms.assetid: d5e8f338-605d-4dff-8a61-7505d5fc46d7
ms.service: documentdb
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: data-services
ms.date: 12/22/2016
ms.author: arramac
ms.openlocfilehash: 5a0f1e7aafb9d3ba2a6105373611a8d94de8bd21
ms.sourcegitcommit: 5b9d839c0c0a94b293fdafe1d6e5429506c07e05
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 08/02/2018
ms.locfileid: "44552321"
---
# <a name="documentdb-indexing-policies"></a><span data-ttu-id="86871-105">DocumentDB indexing policies</span><span class="sxs-lookup"><span data-stu-id="86871-105">DocumentDB indexing policies</span></span>
<span data-ttu-id="86871-106">While many customers are happy to let Azure DocumentDB automatically handle all aspects of indexing, DocumentDB also supports specifying a custom **indexing policy** for collections during creation.</span><span class="sxs-lookup"><span data-stu-id="86871-106">While many customers are happy to let Azure DocumentDB automatically handle all aspects of indexing, DocumentDB also supports specifying a custom **indexing policy** for collections during creation.</span></span> <span data-ttu-id="86871-107">Indexing policies in DocumentDB are more flexible and powerful than secondary indexes offered in other database platforms, because they let you design and customize the shape of the index without sacrificing schema flexibility.</span><span class="sxs-lookup"><span data-stu-id="86871-107">Indexing policies in DocumentDB are more flexible and powerful than secondary indexes offered in other database platforms, because they let you design and customize the shape of the index without sacrificing schema flexibility.</span></span> <span data-ttu-id="86871-108">To learn how indexing works within DocumentDB, you must understand that by managing indexing policy, you can make fine-grained tradeoffs between index storage overhead, write and query throughput, and query consistency.</span><span class="sxs-lookup"><span data-stu-id="86871-108">To learn how indexing works within DocumentDB, you must understand that by managing indexing policy, you can make fine-grained tradeoffs between index storage overhead, write and query throughput, and query consistency.</span></span>  

<span data-ttu-id="86871-109">In this article, we take a close look at DocumentDB indexing policies, how you can customize indexing policy, and the associated trade-offs.</span><span class="sxs-lookup"><span data-stu-id="86871-109">In this article, we take a close look at DocumentDB indexing policies, how you can customize indexing policy, and the associated trade-offs.</span></span> 

<span data-ttu-id="86871-110">After reading this article, you'll be able to answer the following questions:</span><span class="sxs-lookup"><span data-stu-id="86871-110">After reading this article, you'll be able to answer the following questions:</span></span>

* <span data-ttu-id="86871-111">How can I override the properties to include or exclude from indexing?</span><span class="sxs-lookup"><span data-stu-id="86871-111">How can I override the properties to include or exclude from indexing?</span></span>
* <span data-ttu-id="86871-112">How can I configure the index for eventual updates?</span><span class="sxs-lookup"><span data-stu-id="86871-112">How can I configure the index for eventual updates?</span></span>
* <span data-ttu-id="86871-113">How can I configure indexing to perform Order By or range queries?</span><span class="sxs-lookup"><span data-stu-id="86871-113">How can I configure indexing to perform Order By or range queries?</span></span>
* <span data-ttu-id="86871-114">How do I make changes to a collection’s indexing policy?</span><span class="sxs-lookup"><span data-stu-id="86871-114">How do I make changes to a collection’s indexing policy?</span></span>
* <span data-ttu-id="86871-115">How do I compare storage and performance of different indexing policies?</span><span class="sxs-lookup"><span data-stu-id="86871-115">How do I compare storage and performance of different indexing policies?</span></span>

## <a id="CustomizingIndexingPolicy"></a> <span data-ttu-id="86871-116">Customizing the indexing policy of a collection</span><span class="sxs-lookup"><span data-stu-id="86871-116">Customizing the indexing policy of a collection</span></span>
<span data-ttu-id="86871-117">Developers can customize the trade-offs between storage, write/query performance, and query consistency, by overriding the default indexing policy on a DocumentDB collection and configuring the following aspects.</span><span class="sxs-lookup"><span data-stu-id="86871-117">Developers can customize the trade-offs between storage, write/query performance, and query consistency, by overriding the default indexing policy on a DocumentDB collection and configuring the following aspects.</span></span>

* <span data-ttu-id="86871-118">**Including/Excluding documents and paths to/from index**.</span><span class="sxs-lookup"><span data-stu-id="86871-118">**Including/Excluding documents and paths to/from index**.</span></span> <span data-ttu-id="86871-119">Developers can choose certain documents to be excluded or included in the index at the time of inserting or replacing them to the collection.</span><span class="sxs-lookup"><span data-stu-id="86871-119">Developers can choose certain documents to be excluded or included in the index at the time of inserting or replacing them to the collection.</span></span> <span data-ttu-id="86871-120">Developers can also choose to include or exclude certain JSON properties a.k.a.</span><span class="sxs-lookup"><span data-stu-id="86871-120">Developers can also choose to include or exclude certain JSON properties a.k.a.</span></span> <span data-ttu-id="86871-121">paths (including wildcard patterns) to be indexed across documents which are included in an index.</span><span class="sxs-lookup"><span data-stu-id="86871-121">paths (including wildcard patterns) to be indexed across documents which are included in an index.</span></span>
* <span data-ttu-id="86871-122">**Configuring Various Index Types**.</span><span class="sxs-lookup"><span data-stu-id="86871-122">**Configuring Various Index Types**.</span></span> <span data-ttu-id="86871-123">For each of the included paths, developers can also specify the type of index they require over a collection based on their data and expected query workload and the numeric/string “precision” for each path.</span><span class="sxs-lookup"><span data-stu-id="86871-123">For each of the included paths, developers can also specify the type of index they require over a collection based on their data and expected query workload and the numeric/string “precision” for each path.</span></span>
* <span data-ttu-id="86871-124">**Configuring Index Update Modes**.</span><span class="sxs-lookup"><span data-stu-id="86871-124">**Configuring Index Update Modes**.</span></span> <span data-ttu-id="86871-125">DocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection: Consistent, Lazy and None.</span><span class="sxs-lookup"><span data-stu-id="86871-125">DocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection: Consistent, Lazy and None.</span></span> 

<span data-ttu-id="86871-126">The following .NET code snippet shows how to set a custom indexing policy during the creation of a collection.</span><span class="sxs-lookup"><span data-stu-id="86871-126">The following .NET code snippet shows how to set a custom indexing policy during the creation of a collection.</span></span> <span data-ttu-id="86871-127">Here we set the policy with Range index for strings and numbers at the maximum precision.</span><span class="sxs-lookup"><span data-stu-id="86871-127">Here we set the policy with Range index for strings and numbers at the maximum precision.</span></span> <span data-ttu-id="86871-128">This policy lets us execute Order By queries against strings.</span><span class="sxs-lookup"><span data-stu-id="86871-128">This policy lets us execute Order By queries against strings.</span></span>

    DocumentCollection collection = new DocumentCollection { Id = "myCollection" };

    collection.IndexingPolicy = new IndexingPolicy(new RangeIndex(DataType.String) { Precision = -1 });
    collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;

    await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), collection);   


> [!NOTE]
> <span data-ttu-id="86871-129">The JSON schema for indexing policy was changed with the release of REST API version 2015-06-03 to support Range indexes against strings.</span><span class="sxs-lookup"><span data-stu-id="86871-129">The JSON schema for indexing policy was changed with the release of REST API version 2015-06-03 to support Range indexes against strings.</span></span> <span data-ttu-id="86871-130">.NET SDK 1.2.0 and Java, Python, and Node.js SDKs 1.1.0 support the new policy schema.</span><span class="sxs-lookup"><span data-stu-id="86871-130">.NET SDK 1.2.0 and Java, Python, and Node.js SDKs 1.1.0 support the new policy schema.</span></span> <span data-ttu-id="86871-131">Older SDKs use the REST API version 2015-04-08 and support the older schema of Indexing Policy.</span><span class="sxs-lookup"><span data-stu-id="86871-131">Older SDKs use the REST API version 2015-04-08 and support the older schema of Indexing Policy.</span></span>
> 
> <span data-ttu-id="86871-132">By default, DocumentDB indexes all string properties within documents consistently with a Hash index, and numeric properties with a Range index.</span><span class="sxs-lookup"><span data-stu-id="86871-132">By default, DocumentDB indexes all string properties within documents consistently with a Hash index, and numeric properties with a Range index.</span></span>  
> 
> 

### <a name="database-indexing-modes"></a><span data-ttu-id="86871-133">Database indexing modes</span><span class="sxs-lookup"><span data-stu-id="86871-133">Database indexing modes</span></span>
<span data-ttu-id="86871-134">DocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection – Consistent, Lazy and None.</span><span class="sxs-lookup"><span data-stu-id="86871-134">DocumentDB supports three indexing modes which can be configured via the indexing policy on a DocumentDB collection – Consistent, Lazy and None.</span></span>

<span data-ttu-id="86871-135">**Consistent**: If a DocumentDB collection’s policy is designated as "consistent", the queries on a given DocumentDB collection follow the same consistency level as specified for the point-reads (i.e. strong, bounded-staleness, session or eventual).</span><span class="sxs-lookup"><span data-stu-id="86871-135">**Consistent**: If a DocumentDB collection’s policy is designated as "consistent", the queries on a given DocumentDB collection follow the same consistency level as specified for the point-reads (i.e. strong, bounded-staleness, session or eventual).</span></span> <span data-ttu-id="86871-136">The index is updated synchronously as part of the document update (i.e. insert, replace, update, and delete of a document in a DocumentDB collection).</span><span class="sxs-lookup"><span data-stu-id="86871-136">The index is updated synchronously as part of the document update (i.e. insert, replace, update, and delete of a document in a DocumentDB collection).</span></span>  <span data-ttu-id="86871-137">Consistent indexing supports consistent queries at the cost of possible reduction in write throughput.</span><span class="sxs-lookup"><span data-stu-id="86871-137">Consistent indexing supports consistent queries at the cost of possible reduction in write throughput.</span></span> <span data-ttu-id="86871-138">This reduction is a function of the unique paths that need to be indexed and the “consistency level”.</span><span class="sxs-lookup"><span data-stu-id="86871-138">This reduction is a function of the unique paths that need to be indexed and the “consistency level”.</span></span> <span data-ttu-id="86871-139">Consistent indexing mode is designed for “write quickly, query immediately” workloads.</span><span class="sxs-lookup"><span data-stu-id="86871-139">Consistent indexing mode is designed for “write quickly, query immediately” workloads.</span></span>

<span data-ttu-id="86871-140">**Lazy**: To allow maximum document ingestion throughput, a DocumentDB collection can be configured with lazy consistency; meaning queries are eventually consistent.</span><span class="sxs-lookup"><span data-stu-id="86871-140">**Lazy**: To allow maximum document ingestion throughput, a DocumentDB collection can be configured with lazy consistency; meaning queries are eventually consistent.</span></span> <span data-ttu-id="86871-141">The index is updated asynchronously when a DocumentDB collection is quiescent i.e. when the collection’s throughput capacity is not fully utilized to serve user requests.</span><span class="sxs-lookup"><span data-stu-id="86871-141">The index is updated asynchronously when a DocumentDB collection is quiescent i.e. when the collection’s throughput capacity is not fully utilized to serve user requests.</span></span> <span data-ttu-id="86871-142">For "ingest now, query later" workloads requiring unhindered document ingestion, "lazy" indexing mode may be suitable.</span><span class="sxs-lookup"><span data-stu-id="86871-142">For "ingest now, query later" workloads requiring unhindered document ingestion, "lazy" indexing mode may be suitable.</span></span>

<span data-ttu-id="86871-143">**None**: A collection marked with index mode of “None” has no index associated with it.</span><span class="sxs-lookup"><span data-stu-id="86871-143">**None**: A collection marked with index mode of “None” has no index associated with it.</span></span> <span data-ttu-id="86871-144">This is commonly used if DocumentDB is utilized as a key-value storage and documents are accessed only by their ID property.</span><span class="sxs-lookup"><span data-stu-id="86871-144">This is commonly used if DocumentDB is utilized as a key-value storage and documents are accessed only by their ID property.</span></span> 

> [!NOTE]
> <span data-ttu-id="86871-145">Configuring the indexing policy with “None” has the side effect of dropping any existing index.</span><span class="sxs-lookup"><span data-stu-id="86871-145">Configuring the indexing policy with “None” has the side effect of dropping any existing index.</span></span> <span data-ttu-id="86871-146">Use this if your access patterns are only require “id” and/or “self-link”.</span><span class="sxs-lookup"><span data-stu-id="86871-146">Use this if your access patterns are only require “id” and/or “self-link”.</span></span>
> 
> 

<span data-ttu-id="86871-147">The following sample show how create a DocumentDB collection using the .NET SDK with consistent automatic indexing on all document insertions.</span><span class="sxs-lookup"><span data-stu-id="86871-147">The following sample show how create a DocumentDB collection using the .NET SDK with consistent automatic indexing on all document insertions.</span></span>

<span data-ttu-id="86871-148">The following table shows the consistency for queries based on the indexing mode (Consistent and Lazy) configured for the collection and the consistency level specified for the query request.</span><span class="sxs-lookup"><span data-stu-id="86871-148">The following table shows the consistency for queries based on the indexing mode (Consistent and Lazy) configured for the collection and the consistency level specified for the query request.</span></span> <span data-ttu-id="86871-149">This applies to queries made using any interface - REST API, SDKs or from within stored procedures and triggers.</span><span class="sxs-lookup"><span data-stu-id="86871-149">This applies to queries made using any interface - REST API, SDKs or from within stored procedures and triggers.</span></span> 

|<span data-ttu-id="86871-150">Consistency</span><span class="sxs-lookup"><span data-stu-id="86871-150">Consistency</span></span>|<span data-ttu-id="86871-151">Indexing Mode: Consistent</span><span class="sxs-lookup"><span data-stu-id="86871-151">Indexing Mode: Consistent</span></span>|<span data-ttu-id="86871-152">Indexing Mode: Lazy</span><span class="sxs-lookup"><span data-stu-id="86871-152">Indexing Mode: Lazy</span></span>|
|---|---|---|
|<span data-ttu-id="86871-153">Strong</span><span class="sxs-lookup"><span data-stu-id="86871-153">Strong</span></span>|<span data-ttu-id="86871-154">Strong</span><span class="sxs-lookup"><span data-stu-id="86871-154">Strong</span></span>|<span data-ttu-id="86871-155">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-155">Eventual</span></span>|
|<span data-ttu-id="86871-156">Bounded Staleness</span><span class="sxs-lookup"><span data-stu-id="86871-156">Bounded Staleness</span></span>|<span data-ttu-id="86871-157">Bounded Staleness</span><span class="sxs-lookup"><span data-stu-id="86871-157">Bounded Staleness</span></span>|<span data-ttu-id="86871-158">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-158">Eventual</span></span>|
|<span data-ttu-id="86871-159">Session</span><span class="sxs-lookup"><span data-stu-id="86871-159">Session</span></span>|<span data-ttu-id="86871-160">Session</span><span class="sxs-lookup"><span data-stu-id="86871-160">Session</span></span>|<span data-ttu-id="86871-161">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-161">Eventual</span></span>|
|<span data-ttu-id="86871-162">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-162">Eventual</span></span>|<span data-ttu-id="86871-163">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-163">Eventual</span></span>|<span data-ttu-id="86871-164">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-164">Eventual</span></span>|

<span data-ttu-id="86871-165">DocumentDB returns an error for queries made on collections with None indexing mode.</span><span class="sxs-lookup"><span data-stu-id="86871-165">DocumentDB returns an error for queries made on collections with None indexing mode.</span></span> <span data-ttu-id="86871-166">Queries can still be executed as scans via the explicit `x-ms-documentdb-enable-scan` header in the REST API or the `EnableScanInQuery` request option using the .NET SDK.</span><span class="sxs-lookup"><span data-stu-id="86871-166">Queries can still be executed as scans via the explicit `x-ms-documentdb-enable-scan` header in the REST API or the `EnableScanInQuery` request option using the .NET SDK.</span></span> <span data-ttu-id="86871-167">Some query features like ORDER BY are not supported as scans with `EnableScanInQuery`.</span><span class="sxs-lookup"><span data-stu-id="86871-167">Some query features like ORDER BY are not supported as scans with `EnableScanInQuery`.</span></span>

<span data-ttu-id="86871-168">The following table shows the consistency for queries based on the indexing mode (Consistent, Lazy, and None) when EnableScanInQuery is specified.</span><span class="sxs-lookup"><span data-stu-id="86871-168">The following table shows the consistency for queries based on the indexing mode (Consistent, Lazy, and None) when EnableScanInQuery is specified.</span></span>

|<span data-ttu-id="86871-169">Consistency</span><span class="sxs-lookup"><span data-stu-id="86871-169">Consistency</span></span>|<span data-ttu-id="86871-170">Indexing Mode: Consistent</span><span class="sxs-lookup"><span data-stu-id="86871-170">Indexing Mode: Consistent</span></span>|<span data-ttu-id="86871-171">Indexing Mode: Lazy</span><span class="sxs-lookup"><span data-stu-id="86871-171">Indexing Mode: Lazy</span></span>|<span data-ttu-id="86871-172">Indexing Mode: None</span><span class="sxs-lookup"><span data-stu-id="86871-172">Indexing Mode: None</span></span>|
|---|---|---|---|
|<span data-ttu-id="86871-173">Strong</span><span class="sxs-lookup"><span data-stu-id="86871-173">Strong</span></span>|<span data-ttu-id="86871-174">Strong</span><span class="sxs-lookup"><span data-stu-id="86871-174">Strong</span></span>|<span data-ttu-id="86871-175">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-175">Eventual</span></span>|<span data-ttu-id="86871-176">Strong</span><span class="sxs-lookup"><span data-stu-id="86871-176">Strong</span></span>|
|<span data-ttu-id="86871-177">Bounded Staleness</span><span class="sxs-lookup"><span data-stu-id="86871-177">Bounded Staleness</span></span>|<span data-ttu-id="86871-178">Bounded Staleness</span><span class="sxs-lookup"><span data-stu-id="86871-178">Bounded Staleness</span></span>|<span data-ttu-id="86871-179">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-179">Eventual</span></span>|<span data-ttu-id="86871-180">Bounded Staleness</span><span class="sxs-lookup"><span data-stu-id="86871-180">Bounded Staleness</span></span>|
|<span data-ttu-id="86871-181">Session</span><span class="sxs-lookup"><span data-stu-id="86871-181">Session</span></span>|<span data-ttu-id="86871-182">Session</span><span class="sxs-lookup"><span data-stu-id="86871-182">Session</span></span>|<span data-ttu-id="86871-183">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-183">Eventual</span></span>|<span data-ttu-id="86871-184">Session</span><span class="sxs-lookup"><span data-stu-id="86871-184">Session</span></span>|
|<span data-ttu-id="86871-185">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-185">Eventual</span></span>|<span data-ttu-id="86871-186">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-186">Eventual</span></span>|<span data-ttu-id="86871-187">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-187">Eventual</span></span>|<span data-ttu-id="86871-188">Eventual</span><span class="sxs-lookup"><span data-stu-id="86871-188">Eventual</span></span>|

<span data-ttu-id="86871-189">The following code sample show how create a DocumentDB collection using the .NET SDK with consistent indexing on all document insertions.</span><span class="sxs-lookup"><span data-stu-id="86871-189">The following code sample show how create a DocumentDB collection using the .NET SDK with consistent indexing on all document insertions.</span></span>

     // Default collection creates a hash index for all string fields and a range index for all numeric    
     // fields. Hash indexes are compact and offer efficient performance for equality queries.

     var collection = new DocumentCollection { Id ="defaultCollection" };

     collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;

     collection = await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("mydb"), collection);


### <a name="index-paths"></a><span data-ttu-id="86871-190">Index paths</span><span class="sxs-lookup"><span data-stu-id="86871-190">Index paths</span></span>
<span data-ttu-id="86871-191">DocumentDB models JSON documents and the index as trees, and allows you to tune to policies for paths within the tree.</span><span class="sxs-lookup"><span data-stu-id="86871-191">DocumentDB models JSON documents and the index as trees, and allows you to tune to policies for paths within the tree.</span></span> <span data-ttu-id="86871-192">You can find more details in this [introduction to DocumentDB indexing](documentdb-indexing.md).</span><span class="sxs-lookup"><span data-stu-id="86871-192">You can find more details in this [introduction to DocumentDB indexing](documentdb-indexing.md).</span></span> <span data-ttu-id="86871-193">Within documents, you can choose which paths must be included or excluded from indexing.</span><span class="sxs-lookup"><span data-stu-id="86871-193">Within documents, you can choose which paths must be included or excluded from indexing.</span></span> <span data-ttu-id="86871-194">This can offer improved write performance and lower index storage for scenarios when the query patterns are known beforehand.</span><span class="sxs-lookup"><span data-stu-id="86871-194">This can offer improved write performance and lower index storage for scenarios when the query patterns are known beforehand.</span></span>

<span data-ttu-id="86871-195">Index paths start with the root (/) and typically end with the ?</span><span class="sxs-lookup"><span data-stu-id="86871-195">Index paths start with the root (/) and typically end with the ?</span></span> <span data-ttu-id="86871-196">wildcard operator, denoting that there are multiple possible values for the prefix.</span><span class="sxs-lookup"><span data-stu-id="86871-196">wildcard operator, denoting that there are multiple possible values for the prefix.</span></span> <span data-ttu-id="86871-197">For example, to serve SELECT \* FROM Families F WHERE F.familyName = "Andersen", you must include an index path for /familyName/?</span><span class="sxs-lookup"><span data-stu-id="86871-197">For example, to serve SELECT \* FROM Families F WHERE F.familyName = "Andersen", you must include an index path for /familyName/?</span></span> <span data-ttu-id="86871-198">in the collection’s index policy.</span><span class="sxs-lookup"><span data-stu-id="86871-198">in the collection’s index policy.</span></span>

<span data-ttu-id="86871-199">Index paths can also use the \* wildcard operator to specify the behavior for paths recursively under the prefix.</span><span class="sxs-lookup"><span data-stu-id="86871-199">Index paths can also use the \* wildcard operator to specify the behavior for paths recursively under the prefix.</span></span> <span data-ttu-id="86871-200">For example, /payload/\* can be used to exclude everything under the payload property from indexing.</span><span class="sxs-lookup"><span data-stu-id="86871-200">For example, /payload/\* can be used to exclude everything under the payload property from indexing.</span></span>

<span data-ttu-id="86871-201">Here are the common patterns for specifying index paths:</span><span class="sxs-lookup"><span data-stu-id="86871-201">Here are the common patterns for specifying index paths:</span></span>

| <span data-ttu-id="86871-202">Path</span><span class="sxs-lookup"><span data-stu-id="86871-202">Path</span></span>                | <span data-ttu-id="86871-203">Description/use case</span><span class="sxs-lookup"><span data-stu-id="86871-203">Description/use case</span></span>                                                                                                                                                                                                                                                                                         |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| /                   | <span data-ttu-id="86871-204">Default path for collection.</span><span class="sxs-lookup"><span data-stu-id="86871-204">Default path for collection.</span></span> <span data-ttu-id="86871-205">Recursive and applies to whole document tree.</span><span class="sxs-lookup"><span data-stu-id="86871-205">Recursive and applies to whole document tree.</span></span>                                                                                                                                                                                                                                   |
| <span data-ttu-id="86871-206">/prop/?</span><span class="sxs-lookup"><span data-stu-id="86871-206">/prop/?</span></span>             | <span data-ttu-id="86871-207">Index path required to serve queries like the following (with Hash or Range types respectively):</span><span class="sxs-lookup"><span data-stu-id="86871-207">Index path required to serve queries like the following (with Hash or Range types respectively):</span></span><br><br><span data-ttu-id="86871-208">SELECT FROM collection c WHERE c.prop = "value"</span><span class="sxs-lookup"><span data-stu-id="86871-208">SELECT FROM collection c WHERE c.prop = "value"</span></span><br><br><span data-ttu-id="86871-209">SELECT FROM collection c WHERE c.prop > 5</span><span class="sxs-lookup"><span data-stu-id="86871-209">SELECT FROM collection c WHERE c.prop > 5</span></span><br><br><span data-ttu-id="86871-210">SELECT FROM collection c ORDER BY c.prop</span><span class="sxs-lookup"><span data-stu-id="86871-210">SELECT FROM collection c ORDER BY c.prop</span></span>                                                                       |
| <span data-ttu-id="86871-211">/prop/\*</span><span class="sxs-lookup"><span data-stu-id="86871-211">/prop/\*</span></span>             | <span data-ttu-id="86871-212">Index path for all paths under the specified label.</span><span class="sxs-lookup"><span data-stu-id="86871-212">Index path for all paths under the specified label.</span></span> <span data-ttu-id="86871-213">Works with the following queries</span><span class="sxs-lookup"><span data-stu-id="86871-213">Works with the following queries</span></span><br><br><span data-ttu-id="86871-214">SELECT FROM collection c WHERE c.prop = "value"</span><span class="sxs-lookup"><span data-stu-id="86871-214">SELECT FROM collection c WHERE c.prop = "value"</span></span><br><br><span data-ttu-id="86871-215">SELECT FROM collection c WHERE c.prop.subprop > 5</span><span class="sxs-lookup"><span data-stu-id="86871-215">SELECT FROM collection c WHERE c.prop.subprop > 5</span></span><br><br><span data-ttu-id="86871-216">SELECT FROM collection c WHERE c.prop.subprop.nextprop = "value"</span><span class="sxs-lookup"><span data-stu-id="86871-216">SELECT FROM collection c WHERE c.prop.subprop.nextprop = "value"</span></span><br><br><span data-ttu-id="86871-217">SELECT FROM collection c ORDER BY c.prop</span><span class="sxs-lookup"><span data-stu-id="86871-217">SELECT FROM collection c ORDER BY c.prop</span></span>         |
| <span data-ttu-id="86871-218">/props/[]/?</span><span class="sxs-lookup"><span data-stu-id="86871-218">/props/[]/?</span></span>         | <span data-ttu-id="86871-219">Index path required to serve iteration and JOIN queries against arrays of scalars like ["a", "b", "c"]:</span><span class="sxs-lookup"><span data-stu-id="86871-219">Index path required to serve iteration and JOIN queries against arrays of scalars like ["a", "b", "c"]:</span></span><br><br><span data-ttu-id="86871-220">SELECT tag FROM tag IN collection.props WHERE tag = "value"</span><span class="sxs-lookup"><span data-stu-id="86871-220">SELECT tag FROM tag IN collection.props WHERE tag = "value"</span></span><br><br><span data-ttu-id="86871-221">SELECT tag FROM collection c JOIN tag IN c.props WHERE tag > 5</span><span class="sxs-lookup"><span data-stu-id="86871-221">SELECT tag FROM collection c JOIN tag IN c.props WHERE tag > 5</span></span>                                                                         |
| <span data-ttu-id="86871-222">/props/[]/subprop/?</span><span class="sxs-lookup"><span data-stu-id="86871-222">/props/[]/subprop/?</span></span> | <span data-ttu-id="86871-223">Index path required to serve iteration and JOIN queries against arrays of objects like [{subprop: "a"}, {subprop: "b"}]:</span><span class="sxs-lookup"><span data-stu-id="86871-223">Index path required to serve iteration and JOIN queries against arrays of objects like [{subprop: "a"}, {subprop: "b"}]:</span></span><br><br><span data-ttu-id="86871-224">SELECT tag FROM tag IN collection.props WHERE tag.subprop = "value"</span><span class="sxs-lookup"><span data-stu-id="86871-224">SELECT tag FROM tag IN collection.props WHERE tag.subprop = "value"</span></span><br><br><span data-ttu-id="86871-225">SELECT tag FROM collection c JOIN tag IN c.props WHERE tag.subprop = "value"</span><span class="sxs-lookup"><span data-stu-id="86871-225">SELECT tag FROM collection c JOIN tag IN c.props WHERE tag.subprop = "value"</span></span>                                  |
| <span data-ttu-id="86871-226">/prop/subprop/?</span><span class="sxs-lookup"><span data-stu-id="86871-226">/prop/subprop/?</span></span>     | <span data-ttu-id="86871-227">Index path required to serve queries (with Hash or Range types respectively):</span><span class="sxs-lookup"><span data-stu-id="86871-227">Index path required to serve queries (with Hash or Range types respectively):</span></span><br><br><span data-ttu-id="86871-228">SELECT FROM collection c WHERE c.prop.subprop = "value"</span><span class="sxs-lookup"><span data-stu-id="86871-228">SELECT FROM collection c WHERE c.prop.subprop = "value"</span></span><br><br><span data-ttu-id="86871-229">SELECT FROM collection c WHERE c.prop.subprop > 5</span><span class="sxs-lookup"><span data-stu-id="86871-229">SELECT FROM collection c WHERE c.prop.subprop > 5</span></span>                                                                                                                    |

> [!NOTE]
> <span data-ttu-id="86871-230">While setting custom index paths, you are required to specify the default indexing rule for the entire document tree denoted by the special path "/\*".</span><span class="sxs-lookup"><span data-stu-id="86871-230">While setting custom index paths, you are required to specify the default indexing rule for the entire document tree denoted by the special path "/\*".</span></span> 
> 
> 

<span data-ttu-id="86871-231">The following example configures a specific path with range indexing and a custom precision value of 20 bytes:</span><span class="sxs-lookup"><span data-stu-id="86871-231">The following example configures a specific path with range indexing and a custom precision value of 20 bytes:</span></span>

    var collection = new DocumentCollection { Id = "rangeSinglePathCollection" };    

    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/Title/?", 
            Indexes = new Collection<Index> { 
                new RangeIndex(DataType.String) { Precision = 20 } } 
            });

    // Default for everything else
    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/*" ,
            Indexes = new Collection<Index> {
                new HashIndex(DataType.String) { Precision = 3 }, 
                new RangeIndex(DataType.Number) { Precision = -1 } 
            }
        });

    collection = await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), pathRange);


### <a name="index-data-types-kinds-and-precisions"></a><span data-ttu-id="86871-232">Index data types, kinds and precisions</span><span class="sxs-lookup"><span data-stu-id="86871-232">Index data types, kinds and precisions</span></span>
<span data-ttu-id="86871-233">Now that we've taken a look at how to specify paths, let's look at the options we can use to configure the indexing policy for a path.</span><span class="sxs-lookup"><span data-stu-id="86871-233">Now that we've taken a look at how to specify paths, let's look at the options we can use to configure the indexing policy for a path.</span></span> <span data-ttu-id="86871-234">You can specify one or more indexing definitions for every path:</span><span class="sxs-lookup"><span data-stu-id="86871-234">You can specify one or more indexing definitions for every path:</span></span>

* <span data-ttu-id="86871-235">Data type: **String**, **Number**, **Point**, **Polygon**, or **LineString** (can contain only one entry per data type per path)</span><span class="sxs-lookup"><span data-stu-id="86871-235">Data type: **String**, **Number**, **Point**, **Polygon**, or **LineString** (can contain only one entry per data type per path)</span></span>
* <span data-ttu-id="86871-236">Index kind: **Hash** (equality queries), **Range** (equality, range or Order By queries), or **Spatial** (spatial queries)</span><span class="sxs-lookup"><span data-stu-id="86871-236">Index kind: **Hash** (equality queries), **Range** (equality, range or Order By queries), or **Spatial** (spatial queries)</span></span> 
* <span data-ttu-id="86871-237">Precision: 1-8 or -1 (Maximum precision) for numbers, 1-100 (Maximum precision) for string</span><span class="sxs-lookup"><span data-stu-id="86871-237">Precision: 1-8 or -1 (Maximum precision) for numbers, 1-100 (Maximum precision) for string</span></span>

#### <a name="index-kind"></a><span data-ttu-id="86871-238">Index kind</span><span class="sxs-lookup"><span data-stu-id="86871-238">Index kind</span></span>
<span data-ttu-id="86871-239">DocumentDB supports Hash and Range index kinds for every path (that can configured for strings, numbers or both).</span><span class="sxs-lookup"><span data-stu-id="86871-239">DocumentDB supports Hash and Range index kinds for every path (that can configured for strings, numbers or both).</span></span>

* <span data-ttu-id="86871-240">**Hash** supports efficient equality and JOIN queries.</span><span class="sxs-lookup"><span data-stu-id="86871-240">**Hash** supports efficient equality and JOIN queries.</span></span> <span data-ttu-id="86871-241">For most use cases, hash indexes do not need a higher precision than the default value of 3 bytes.</span><span class="sxs-lookup"><span data-stu-id="86871-241">For most use cases, hash indexes do not need a higher precision than the default value of 3 bytes.</span></span> <span data-ttu-id="86871-242">DataType can be String or Number.</span><span class="sxs-lookup"><span data-stu-id="86871-242">DataType can be String or Number.</span></span>
* <span data-ttu-id="86871-243">**Range** supports efficient equality queries, range queries (using >, <, >=, <=, !=), and Order By queries.</span><span class="sxs-lookup"><span data-stu-id="86871-243">**Range** supports efficient equality queries, range queries (using >, <, >=, <=, !=), and Order By queries.</span></span> <span data-ttu-id="86871-244">Order By queries by default also require maximum index precision (-1).</span><span class="sxs-lookup"><span data-stu-id="86871-244">Order By queries by default also require maximum index precision (-1).</span></span> <span data-ttu-id="86871-245">DataType can be String or Number.</span><span class="sxs-lookup"><span data-stu-id="86871-245">DataType can be String or Number.</span></span>

<span data-ttu-id="86871-246">DocumentDB also supports the Spatial index kind for every path, that can be specified for the Point, Polygon, or LineString data types.</span><span class="sxs-lookup"><span data-stu-id="86871-246">DocumentDB also supports the Spatial index kind for every path, that can be specified for the Point, Polygon, or LineString data types.</span></span> <span data-ttu-id="86871-247">The value at the specified path must be a valid GeoJSON fragment like `{"type": "Point", "coordinates": [0.0, 10.0]}`.</span><span class="sxs-lookup"><span data-stu-id="86871-247">The value at the specified path must be a valid GeoJSON fragment like `{"type": "Point", "coordinates": [0.0, 10.0]}`.</span></span>

* <span data-ttu-id="86871-248">**Spatial** supports efficient spatial (within and distance) queries.</span><span class="sxs-lookup"><span data-stu-id="86871-248">**Spatial** supports efficient spatial (within and distance) queries.</span></span> <span data-ttu-id="86871-249">DataType can be Point, Polygon, or LineString.</span><span class="sxs-lookup"><span data-stu-id="86871-249">DataType can be Point, Polygon, or LineString.</span></span>

> [!NOTE]
> <span data-ttu-id="86871-250">DocumentDB supports automatic indexing of Points, Polygons, and LineStrings.</span><span class="sxs-lookup"><span data-stu-id="86871-250">DocumentDB supports automatic indexing of Points, Polygons, and LineStrings.</span></span>
> 
> 

<span data-ttu-id="86871-251">Here are the supported index kinds and examples of queries that they can be used to serve:</span><span class="sxs-lookup"><span data-stu-id="86871-251">Here are the supported index kinds and examples of queries that they can be used to serve:</span></span>

| <span data-ttu-id="86871-252">Index kind</span><span class="sxs-lookup"><span data-stu-id="86871-252">Index kind</span></span> | <span data-ttu-id="86871-253">Description/use case</span><span class="sxs-lookup"><span data-stu-id="86871-253">Description/use case</span></span>                                                                                                                                                                                                                                                                                                                                                                                                              |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="86871-254">Hash</span><span class="sxs-lookup"><span data-stu-id="86871-254">Hash</span></span>       | <span data-ttu-id="86871-255">Hash over /prop/?</span><span class="sxs-lookup"><span data-stu-id="86871-255">Hash over /prop/?</span></span> <span data-ttu-id="86871-256">(or /) can be used to serve the following queries efficiently:</span><span class="sxs-lookup"><span data-stu-id="86871-256">(or /) can be used to serve the following queries efficiently:</span></span><br><br><span data-ttu-id="86871-257">SELECT FROM collection c WHERE c.prop = "value"</span><span class="sxs-lookup"><span data-stu-id="86871-257">SELECT FROM collection c WHERE c.prop = "value"</span></span><br><br><span data-ttu-id="86871-258">Hash over /props/[]/?</span><span class="sxs-lookup"><span data-stu-id="86871-258">Hash over /props/[]/?</span></span> <span data-ttu-id="86871-259">(or / or /props/) can be used to serve the following queries efficiently:</span><span class="sxs-lookup"><span data-stu-id="86871-259">(or / or /props/) can be used to serve the following queries efficiently:</span></span><br><br><span data-ttu-id="86871-260">SELECT tag FROM collection c JOIN tag IN c.props WHERE tag = 5</span><span class="sxs-lookup"><span data-stu-id="86871-260">SELECT tag FROM collection c JOIN tag IN c.props WHERE tag = 5</span></span>                                                                                                                       |
| <span data-ttu-id="86871-261">Range</span><span class="sxs-lookup"><span data-stu-id="86871-261">Range</span></span>      | <span data-ttu-id="86871-262">Range over /prop/?</span><span class="sxs-lookup"><span data-stu-id="86871-262">Range over /prop/?</span></span> <span data-ttu-id="86871-263">(or /) can be used to serve the following queries efficiently:</span><span class="sxs-lookup"><span data-stu-id="86871-263">(or /) can be used to serve the following queries efficiently:</span></span><br><br><span data-ttu-id="86871-264">SELECT FROM collection c WHERE c.prop = "value"</span><span class="sxs-lookup"><span data-stu-id="86871-264">SELECT FROM collection c WHERE c.prop = "value"</span></span><br><br><span data-ttu-id="86871-265">SELECT FROM collection c WHERE c.prop > 5</span><span class="sxs-lookup"><span data-stu-id="86871-265">SELECT FROM collection c WHERE c.prop > 5</span></span><br><br><span data-ttu-id="86871-266">SELECT FROM collection c ORDER BY c.prop</span><span class="sxs-lookup"><span data-stu-id="86871-266">SELECT FROM collection c ORDER BY c.prop</span></span>                                                                                                                                                                                                              |
| <span data-ttu-id="86871-267">Spatial</span><span class="sxs-lookup"><span data-stu-id="86871-267">Spatial</span></span>     | <span data-ttu-id="86871-268">Range over /prop/?</span><span class="sxs-lookup"><span data-stu-id="86871-268">Range over /prop/?</span></span> <span data-ttu-id="86871-269">(or /) can be used to serve the following queries efficiently:</span><span class="sxs-lookup"><span data-stu-id="86871-269">(or /) can be used to serve the following queries efficiently:</span></span><br><br><span data-ttu-id="86871-270">SELECT FROM collection c</span><span class="sxs-lookup"><span data-stu-id="86871-270">SELECT FROM collection c</span></span><br><br><span data-ttu-id="86871-271">WHERE ST_DISTANCE(c.prop, {"type": "Point", "coordinates": [0.0, 10.0]}) < 40</span><span class="sxs-lookup"><span data-stu-id="86871-271">WHERE ST_DISTANCE(c.prop, {"type": "Point", "coordinates": [0.0, 10.0]}) < 40</span></span><br><br><span data-ttu-id="86871-272">SELECT FROM collection c WHERE ST_WITHIN(c.prop, {"type": "Polygon", ... }) --with indexing on points enabled</span><span class="sxs-lookup"><span data-stu-id="86871-272">SELECT FROM collection c WHERE ST_WITHIN(c.prop, {"type": "Polygon", ... }) --with indexing on points enabled</span></span><br><br><span data-ttu-id="86871-273">SELECT FROM collection c WHERE ST_WITHIN({"type": "Point", ... }, c.prop) --with indexing on polygons enabled</span><span class="sxs-lookup"><span data-stu-id="86871-273">SELECT FROM collection c WHERE ST_WITHIN({"type": "Point", ... }, c.prop) --with indexing on polygons enabled</span></span>              |

<span data-ttu-id="86871-274">By default, an error is returned for queries with range operators such as >= if there is no range index (of any precision) in order to signal that a scan might be necessary to serve the query.</span><span class="sxs-lookup"><span data-stu-id="86871-274">By default, an error is returned for queries with range operators such as >= if there is no range index (of any precision) in order to signal that a scan might be necessary to serve the query.</span></span> <span data-ttu-id="86871-275">Range queries can be performed without a range index using the x-ms-documentdb-enable-scan header in the REST API or the EnableScanInQuery request option using the .NET SDK.</span><span class="sxs-lookup"><span data-stu-id="86871-275">Range queries can be performed without a range index using the x-ms-documentdb-enable-scan header in the REST API or the EnableScanInQuery request option using the .NET SDK.</span></span> <span data-ttu-id="86871-276">If there are any other filters in the query that DocumentDB can use the index to filter against, then no error will be returned.</span><span class="sxs-lookup"><span data-stu-id="86871-276">If there are any other filters in the query that DocumentDB can use the index to filter against, then no error will be returned.</span></span>

<span data-ttu-id="86871-277">The same rules apply for spatial queries.</span><span class="sxs-lookup"><span data-stu-id="86871-277">The same rules apply for spatial queries.</span></span> <span data-ttu-id="86871-278">By default, an error is returned for spatial queries if there is no spatial index, and there are no other filters that can be served from the index.</span><span class="sxs-lookup"><span data-stu-id="86871-278">By default, an error is returned for spatial queries if there is no spatial index, and there are no other filters that can be served from the index.</span></span> <span data-ttu-id="86871-279">They can be performed as a scan using x-ms-documentdb-enable-scan/EnableScanInQuery.</span><span class="sxs-lookup"><span data-stu-id="86871-279">They can be performed as a scan using x-ms-documentdb-enable-scan/EnableScanInQuery.</span></span>

#### <a name="index-precision"></a><span data-ttu-id="86871-280">Index precision</span><span class="sxs-lookup"><span data-stu-id="86871-280">Index precision</span></span>
<span data-ttu-id="86871-281">Index precision lets you tradeoff between index storage overhead and query performance.</span><span class="sxs-lookup"><span data-stu-id="86871-281">Index precision lets you tradeoff between index storage overhead and query performance.</span></span> <span data-ttu-id="86871-282">For numbers, we recommend using the default precision configuration of -1 ("maximum").</span><span class="sxs-lookup"><span data-stu-id="86871-282">For numbers, we recommend using the default precision configuration of -1 ("maximum").</span></span> <span data-ttu-id="86871-283">Since numbers are 8 bytes in JSON, this is equivalent to a configuration of 8 bytes.</span><span class="sxs-lookup"><span data-stu-id="86871-283">Since numbers are 8 bytes in JSON, this is equivalent to a configuration of 8 bytes.</span></span> <span data-ttu-id="86871-284">Picking a lower value for precision, such as 1-7, means that values within some ranges map to the same index entry.</span><span class="sxs-lookup"><span data-stu-id="86871-284">Picking a lower value for precision, such as 1-7, means that values within some ranges map to the same index entry.</span></span> <span data-ttu-id="86871-285">Therefore you will reduce index storage space, but query execution might have to process more documents and consequently consume more throughput i.e., request units.</span><span class="sxs-lookup"><span data-stu-id="86871-285">Therefore you will reduce index storage space, but query execution might have to process more documents and consequently consume more throughput i.e., request units.</span></span>

<span data-ttu-id="86871-286">Index precision configuration has more practical application with string ranges.</span><span class="sxs-lookup"><span data-stu-id="86871-286">Index precision configuration has more practical application with string ranges.</span></span> <span data-ttu-id="86871-287">Since strings can be any arbitrary length, the choice of the index precision can impact the performance of string range queries, and impact the amount of index storage space required.</span><span class="sxs-lookup"><span data-stu-id="86871-287">Since strings can be any arbitrary length, the choice of the index precision can impact the performance of string range queries, and impact the amount of index storage space required.</span></span> <span data-ttu-id="86871-288">String range indexes can be configured with 1-100 or -1 ("maximum").</span><span class="sxs-lookup"><span data-stu-id="86871-288">String range indexes can be configured with 1-100 or -1 ("maximum").</span></span> <span data-ttu-id="86871-289">If you would like to perform Order By queries against string properties, then you must specify a precision of -1 for the corresponding paths.</span><span class="sxs-lookup"><span data-stu-id="86871-289">If you would like to perform Order By queries against string properties, then you must specify a precision of -1 for the corresponding paths.</span></span>

<span data-ttu-id="86871-290">Spatial indexes always use the default index precision for all types (Points, LineStrings, and Polygons) and cannot be overriden.</span><span class="sxs-lookup"><span data-stu-id="86871-290">Spatial indexes always use the default index precision for all types (Points, LineStrings, and Polygons) and cannot be overriden.</span></span> 

<span data-ttu-id="86871-291">The following example shows how to increase the precision for range indexes in a collection using the .NET SDK.</span><span class="sxs-lookup"><span data-stu-id="86871-291">The following example shows how to increase the precision for range indexes in a collection using the .NET SDK.</span></span> 

<span data-ttu-id="86871-292">**Create a collection with a custom index precision**</span><span class="sxs-lookup"><span data-stu-id="86871-292">**Create a collection with a custom index precision**</span></span>

    var rangeDefault = new DocumentCollection { Id = "rangeCollection" };

    // Override the default policy for Strings to range indexing and "max" (-1) precision
    rangeDefault.IndexingPolicy = new IndexingPolicy(new RangeIndex(DataType.String) { Precision = -1 });

    await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), rangeDefault);   


> [!NOTE]
> <span data-ttu-id="86871-293">DocumentDB returns an error when a query uses Order By but does not have a range index against the queried path with the maximum precision.</span><span class="sxs-lookup"><span data-stu-id="86871-293">DocumentDB returns an error when a query uses Order By but does not have a range index against the queried path with the maximum precision.</span></span> 
> 
> 

<span data-ttu-id="86871-294">Similarly, paths can be completely excluded from indexing.</span><span class="sxs-lookup"><span data-stu-id="86871-294">Similarly, paths can be completely excluded from indexing.</span></span> <span data-ttu-id="86871-295">The next example shows how to exclude an entire section of the documents (a.k.a.</span><span class="sxs-lookup"><span data-stu-id="86871-295">The next example shows how to exclude an entire section of the documents (a.k.a.</span></span> <span data-ttu-id="86871-296">a sub-tree) from indexing using the "\*" wildcard.</span><span class="sxs-lookup"><span data-stu-id="86871-296">a sub-tree) from indexing using the "\*" wildcard.</span></span>

    var collection = new DocumentCollection { Id = "excludedPathCollection" };
    collection.IndexingPolicy.IncludedPaths.Add(new IncludedPath { Path = "/*" });
    collection.IndexingPolicy.ExcludedPaths.Add(new ExcludedPath { Path = "/nonIndexedContent/*");

    collection = await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), excluded);



## <a name="opting-in-and-opting-out-of-indexing"></a><span data-ttu-id="86871-297">Opting in and opting out of indexing</span><span class="sxs-lookup"><span data-stu-id="86871-297">Opting in and opting out of indexing</span></span>
<span data-ttu-id="86871-298">You can choose whether you want the collection to automatically index all documents.</span><span class="sxs-lookup"><span data-stu-id="86871-298">You can choose whether you want the collection to automatically index all documents.</span></span> <span data-ttu-id="86871-299">By default, all documents are automatically indexed, but you can choose to turn it off.</span><span class="sxs-lookup"><span data-stu-id="86871-299">By default, all documents are automatically indexed, but you can choose to turn it off.</span></span> <span data-ttu-id="86871-300">When indexing is turned off, documents can be accessed only through their self-links or by queries using ID.</span><span class="sxs-lookup"><span data-stu-id="86871-300">When indexing is turned off, documents can be accessed only through their self-links or by queries using ID.</span></span>

<span data-ttu-id="86871-301">With automatic indexing turned off, you can still selectively add only specific documents to the index.</span><span class="sxs-lookup"><span data-stu-id="86871-301">With automatic indexing turned off, you can still selectively add only specific documents to the index.</span></span> <span data-ttu-id="86871-302">Conversely, you can leave automatic indexing on and selectively choose to exclude only specific documents.</span><span class="sxs-lookup"><span data-stu-id="86871-302">Conversely, you can leave automatic indexing on and selectively choose to exclude only specific documents.</span></span> <span data-ttu-id="86871-303">Indexing on/off configurations are useful when you have only a subset of documents that need to be queried.</span><span class="sxs-lookup"><span data-stu-id="86871-303">Indexing on/off configurations are useful when you have only a subset of documents that need to be queried.</span></span>

<span data-ttu-id="86871-304">For example, the following sample shows how to include a document explicitly using the [DocumentDB .NET SDK](https://github.com/Azure/azure-documentdb-java) and the [RequestOptions.IndexingDirective](http://msdn.microsoft.com/library/microsoft.azure.documents.client.requestoptions.indexingdirective.aspx) property.</span><span class="sxs-lookup"><span data-stu-id="86871-304">For example, the following sample shows how to include a document explicitly using the [DocumentDB .NET SDK](https://github.com/Azure/azure-documentdb-java) and the [RequestOptions.IndexingDirective](http://msdn.microsoft.com/library/microsoft.azure.documents.client.requestoptions.indexingdirective.aspx) property.</span></span>

    // If you want to override the default collection behavior to either
    // exclude (or include) a Document from indexing,
    // use the RequestOptions.IndexingDirective property.
    client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri("db", "coll"),
        new { id = "AndersenFamily", isRegistered = true },
        new RequestOptions { IndexingDirective = IndexingDirective.Include });

## <a name="modifying-the-indexing-policy-of-a-collection"></a><span data-ttu-id="86871-305">Modifying the indexing policy of a collection</span><span class="sxs-lookup"><span data-stu-id="86871-305">Modifying the indexing policy of a collection</span></span>
<span data-ttu-id="86871-306">DocumentDB allows you to make changes to the indexing policy of a collection on the fly.</span><span class="sxs-lookup"><span data-stu-id="86871-306">DocumentDB allows you to make changes to the indexing policy of a collection on the fly.</span></span> <span data-ttu-id="86871-307">A change in indexing policy on a DocumentDB collection can lead to a change in the shape of the index including the paths can be indexed, their precision, as well as the consistency model of the index itself.</span><span class="sxs-lookup"><span data-stu-id="86871-307">A change in indexing policy on a DocumentDB collection can lead to a change in the shape of the index including the paths can be indexed, their precision, as well as the consistency model of the index itself.</span></span> <span data-ttu-id="86871-308">Thus a change in indexing policy, effectively requires a transformation of the old index into a new one.</span><span class="sxs-lookup"><span data-stu-id="86871-308">Thus a change in indexing policy, effectively requires a transformation of the old index into a new one.</span></span> 

<span data-ttu-id="86871-309">**Online Index Transformations**</span><span class="sxs-lookup"><span data-stu-id="86871-309">**Online Index Transformations**</span></span>

![How indexing works – DocumentDB online index transformations](https://docstestmedia1.blob.core.windows.net/azure-media/articles/documentdb/media/documentdb-indexing-policies/index-transformations.png)

<span data-ttu-id="86871-311">Index transformations are made online, meaning that the documents indexed per the old policy are efficiently transformed per the new policy **without affecting the write availability or the provisioned throughput** of the collection.</span><span class="sxs-lookup"><span data-stu-id="86871-311">Index transformations are made online, meaning that the documents indexed per the old policy are efficiently transformed per the new policy **without affecting the write availability or the provisioned throughput** of the collection.</span></span> <span data-ttu-id="86871-312">The consistency of read and write operations made using the REST API, SDKs or from within stored procedures and triggers is not impacted during index transformation.</span><span class="sxs-lookup"><span data-stu-id="86871-312">The consistency of read and write operations made using the REST API, SDKs or from within stored procedures and triggers is not impacted during index transformation.</span></span> <span data-ttu-id="86871-313">This means that there is no performance degradation or downtime to your apps when you make an indexing policy change.</span><span class="sxs-lookup"><span data-stu-id="86871-313">This means that there is no performance degradation or downtime to your apps when you make an indexing policy change.</span></span>

<span data-ttu-id="86871-314">However, during the time that index transformation is progress, queries are eventually consistent regardless of the indexing mode configuration (Consistent or Lazy).</span><span class="sxs-lookup"><span data-stu-id="86871-314">However, during the time that index transformation is progress, queries are eventually consistent regardless of the indexing mode configuration (Consistent or Lazy).</span></span> <span data-ttu-id="86871-315">This also applies to queries from all interfaces – REST API, SDKs, and from within stored procedures and triggers.</span><span class="sxs-lookup"><span data-stu-id="86871-315">This also applies to queries from all interfaces – REST API, SDKs, and from within stored procedures and triggers.</span></span> <span data-ttu-id="86871-316">Just like with Lazy indexing, index transformation is performed asynchronously in the background on the replicas using the spare resources available for a given replica.</span><span class="sxs-lookup"><span data-stu-id="86871-316">Just like with Lazy indexing, index transformation is performed asynchronously in the background on the replicas using the spare resources available for a given replica.</span></span> 

<span data-ttu-id="86871-317">Index transformations are also made **in-situ** (in place), i.e. DocumentDB does not maintain two copies of the index and swap the old index out with the new one.</span><span class="sxs-lookup"><span data-stu-id="86871-317">Index transformations are also made **in-situ** (in place), i.e. DocumentDB does not maintain two copies of the index and swap the old index out with the new one.</span></span> <span data-ttu-id="86871-318">This means that no additional disk space is required or consumed in your collections while performing index transformations.</span><span class="sxs-lookup"><span data-stu-id="86871-318">This means that no additional disk space is required or consumed in your collections while performing index transformations.</span></span>

<span data-ttu-id="86871-319">When you change indexing policy, how the changes are applied to move from the old index to the new one depend primarily on the indexing mode configurations more so than the other values like included/excluded paths, index kinds and precisions.</span><span class="sxs-lookup"><span data-stu-id="86871-319">When you change indexing policy, how the changes are applied to move from the old index to the new one depend primarily on the indexing mode configurations more so than the other values like included/excluded paths, index kinds and precisions.</span></span> <span data-ttu-id="86871-320">If both your old and new policies use consistent indexing, then DocumentDB performs an online index transformation.</span><span class="sxs-lookup"><span data-stu-id="86871-320">If both your old and new policies use consistent indexing, then DocumentDB performs an online index transformation.</span></span> <span data-ttu-id="86871-321">You cannot apply another indexing policy change with consistent indexing mode while the transformation is in progress.</span><span class="sxs-lookup"><span data-stu-id="86871-321">You cannot apply another indexing policy change with consistent indexing mode while the transformation is in progress.</span></span>

<span data-ttu-id="86871-322">You can however move to Lazy or None indexing mode while a transformation is in progress.</span><span class="sxs-lookup"><span data-stu-id="86871-322">You can however move to Lazy or None indexing mode while a transformation is in progress.</span></span> 

* <span data-ttu-id="86871-323">When you move to Lazy, the index policy change is made effective immediately and DocumentDB starts recreating the index asynchronously.</span><span class="sxs-lookup"><span data-stu-id="86871-323">When you move to Lazy, the index policy change is made effective immediately and DocumentDB starts recreating the index asynchronously.</span></span> 
* <span data-ttu-id="86871-324">When you move to None, then the index is dropped effective immediately.</span><span class="sxs-lookup"><span data-stu-id="86871-324">When you move to None, then the index is dropped effective immediately.</span></span> <span data-ttu-id="86871-325">Moving to None is useful when you want to cancel an in progress transformation and start fresh with a different indexing policy.</span><span class="sxs-lookup"><span data-stu-id="86871-325">Moving to None is useful when you want to cancel an in progress transformation and start fresh with a different indexing policy.</span></span> 

<span data-ttu-id="86871-326">If you’re using the .NET SDK, you can kick of an indexing policy change using the new **ReplaceDocumentCollectionAsync** method and track the percentage progress of the index transformation using the **IndexTransformationProgress** response property from a **ReadDocumentCollectionAsync** call.</span><span class="sxs-lookup"><span data-stu-id="86871-326">If you’re using the .NET SDK, you can kick of an indexing policy change using the new **ReplaceDocumentCollectionAsync** method and track the percentage progress of the index transformation using the **IndexTransformationProgress** response property from a **ReadDocumentCollectionAsync** call.</span></span> <span data-ttu-id="86871-327">Other SDKs and the REST API support equivalent properties and methods for making indexing policy changes.</span><span class="sxs-lookup"><span data-stu-id="86871-327">Other SDKs and the REST API support equivalent properties and methods for making indexing policy changes.</span></span>

<span data-ttu-id="86871-328">Here's a code snippet that shows how to modify a collection's indexing policy from Consistent indexing mode to Lazy.</span><span class="sxs-lookup"><span data-stu-id="86871-328">Here's a code snippet that shows how to modify a collection's indexing policy from Consistent indexing mode to Lazy.</span></span>

<span data-ttu-id="86871-329">**Modify Indexing Policy from Consistent to Lazy**</span><span class="sxs-lookup"><span data-stu-id="86871-329">**Modify Indexing Policy from Consistent to Lazy**</span></span>

    // Switch to lazy indexing.
    Console.WriteLine("Changing from Default to Lazy IndexingMode.");

    collection.IndexingPolicy.IndexingMode = IndexingMode.Lazy;

    await client.ReplaceDocumentCollectionAsync(collection);


<span data-ttu-id="86871-330">You can check the progress of an index transformation by calling ReadDocumentCollectionAsync, for example, as shown below.</span><span class="sxs-lookup"><span data-stu-id="86871-330">You can check the progress of an index transformation by calling ReadDocumentCollectionAsync, for example, as shown below.</span></span>

<span data-ttu-id="86871-331">**Track Progress of Index Transformation**</span><span class="sxs-lookup"><span data-stu-id="86871-331">**Track Progress of Index Transformation**</span></span>

    long smallWaitTimeMilliseconds = 1000;
    long progress = 0;

    while (progress < 100)
    {
        ResourceResponse<DocumentCollection> collectionReadResponse = await client.ReadDocumentCollectionAsync(
            UriFactory.CreateDocumentCollectionUri("db", "coll"));

        progress = collectionReadResponse.IndexTransformationProgress;

        await Task.Delay(TimeSpan.FromMilliseconds(smallWaitTimeMilliseconds));
    }

<span data-ttu-id="86871-332">You can drop the index for a collection by moving to the None indexing mode.</span><span class="sxs-lookup"><span data-stu-id="86871-332">You can drop the index for a collection by moving to the None indexing mode.</span></span> <span data-ttu-id="86871-333">This might be a useful operational tool if you want to cancel an in-progress transformation and start a new one immediately.</span><span class="sxs-lookup"><span data-stu-id="86871-333">This might be a useful operational tool if you want to cancel an in-progress transformation and start a new one immediately.</span></span>

<span data-ttu-id="86871-334">**Dropping the index for a collection**</span><span class="sxs-lookup"><span data-stu-id="86871-334">**Dropping the index for a collection**</span></span>

    // Switch to lazy indexing.
    Console.WriteLine("Dropping index by changing to to the None IndexingMode.");

    collection.IndexingPolicy.IndexingMode = IndexingMode.None;

    await client.ReplaceDocumentCollectionAsync(collection);

<span data-ttu-id="86871-335">When would you make indexing policy changes to your DocumentDB collections?</span><span class="sxs-lookup"><span data-stu-id="86871-335">When would you make indexing policy changes to your DocumentDB collections?</span></span> <span data-ttu-id="86871-336">The following are the most common use cases:</span><span class="sxs-lookup"><span data-stu-id="86871-336">The following are the most common use cases:</span></span>

* <span data-ttu-id="86871-337">Serve consistent results during normal operation, but fall back to lazy indexing during bulk data imports</span><span class="sxs-lookup"><span data-stu-id="86871-337">Serve consistent results during normal operation, but fall back to lazy indexing during bulk data imports</span></span>
* <span data-ttu-id="86871-338">Start using new indexing features on your current DocumentDB collections, e.g., like geospatial querying which require the Spatial index kind, or Order By/string range queries which require the string Range index kind</span><span class="sxs-lookup"><span data-stu-id="86871-338">Start using new indexing features on your current DocumentDB collections, e.g., like geospatial querying which require the Spatial index kind, or Order By/string range queries which require the string Range index kind</span></span>
* <span data-ttu-id="86871-339">Hand select the properties to be indexed and change them over time</span><span class="sxs-lookup"><span data-stu-id="86871-339">Hand select the properties to be indexed and change them over time</span></span>
* <span data-ttu-id="86871-340">Tune indexing precision to improve query performance or reduce storage consumed</span><span class="sxs-lookup"><span data-stu-id="86871-340">Tune indexing precision to improve query performance or reduce storage consumed</span></span>

> [!NOTE]
> <span data-ttu-id="86871-341">To modify indexing policy using ReplaceDocumentCollectionAsync, you need version >= 1.3.0 of the .NET SDK</span><span class="sxs-lookup"><span data-stu-id="86871-341">To modify indexing policy using ReplaceDocumentCollectionAsync, you need version >= 1.3.0 of the .NET SDK</span></span>
> 
> <span data-ttu-id="86871-342">For index transformation to complete successfully, you must ensure that there is sufficient free storage space available on the collection.</span><span class="sxs-lookup"><span data-stu-id="86871-342">For index transformation to complete successfully, you must ensure that there is sufficient free storage space available on the collection.</span></span> <span data-ttu-id="86871-343">If the collection reaches its storage quota, then the index transformation will be paused.</span><span class="sxs-lookup"><span data-stu-id="86871-343">If the collection reaches its storage quota, then the index transformation will be paused.</span></span> <span data-ttu-id="86871-344">Index transformation will automatically resume once storage space is available, e.g. if you delete some documents.</span><span class="sxs-lookup"><span data-stu-id="86871-344">Index transformation will automatically resume once storage space is available, e.g. if you delete some documents.</span></span>
> 
> 

## <a name="performance-tuning"></a><span data-ttu-id="86871-345">Performance tuning</span><span class="sxs-lookup"><span data-stu-id="86871-345">Performance tuning</span></span>
<span data-ttu-id="86871-346">The DocumentDB APIs provide information about performance metrics such as the index storage used, and the throughput cost (request units) for every operation.</span><span class="sxs-lookup"><span data-stu-id="86871-346">The DocumentDB APIs provide information about performance metrics such as the index storage used, and the throughput cost (request units) for every operation.</span></span> <span data-ttu-id="86871-347">This information can be used to compare various indexing policies and for performance tuning.</span><span class="sxs-lookup"><span data-stu-id="86871-347">This information can be used to compare various indexing policies and for performance tuning.</span></span>

<span data-ttu-id="86871-348">To check the storage quota and usage of a collection, run a HEAD or GET request against the collection resource, and inspect the x-ms-request-quota and the x-ms-request-usage headers.</span><span class="sxs-lookup"><span data-stu-id="86871-348">To check the storage quota and usage of a collection, run a HEAD or GET request against the collection resource, and inspect the x-ms-request-quota and the x-ms-request-usage headers.</span></span> <span data-ttu-id="86871-349">In the .NET SDK, the [DocumentSizeQuota](http://msdn.microsoft.com/library/dn850325.aspx) and [DocumentSizeUsage](http://msdn.microsoft.com/library/azure/dn850324.aspx) properties in [ResourceResponse<T\>](http://msdn.microsoft.com/library/dn799209.aspx) contain these corresponding values.</span><span class="sxs-lookup"><span data-stu-id="86871-349">In the .NET SDK, the [DocumentSizeQuota](http://msdn.microsoft.com/library/dn850325.aspx) and [DocumentSizeUsage](http://msdn.microsoft.com/library/azure/dn850324.aspx) properties in [ResourceResponse<T\>](http://msdn.microsoft.com/library/dn799209.aspx) contain these corresponding values.</span></span>

     // Measure the document size usage (which includes the index size) against   
     // different policies.
     ResourceResponse<DocumentCollection> collectionInfo = await client.ReadDocumentCollectionAsync(UriFactory.CreateDocumentCollectionUri("db", "coll"));  
     Console.WriteLine("Document size quota: {0}, usage: {1}", collectionInfo.DocumentQuota, collectionInfo.DocumentUsage);


<span data-ttu-id="86871-350">To measure the overhead of indexing on each write operation (create, update, or delete), inspect the x-ms-request-charge header (or the equivalent [RequestCharge](http://msdn.microsoft.com/library/dn799099.aspx) property in [ResourceResponse<T\>](http://msdn.microsoft.com/library/dn799209.aspx) in the .NET SDK) to measure the number of request units consumed by these operations.</span><span class="sxs-lookup"><span data-stu-id="86871-350">To measure the overhead of indexing on each write operation (create, update, or delete), inspect the x-ms-request-charge header (or the equivalent [RequestCharge](http://msdn.microsoft.com/library/dn799099.aspx) property in [ResourceResponse<T\>](http://msdn.microsoft.com/library/dn799209.aspx) in the .NET SDK) to measure the number of request units consumed by these operations.</span></span>

     // Measure the performance (request units) of writes.     
     ResourceResponse<Document> response = await client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri("db", "coll"), myDocument);              
     Console.WriteLine("Insert of document consumed {0} request units", response.RequestCharge);

     // Measure the performance (request units) of queries.    
     IDocumentQuery<dynamic> queryable =  client.CreateDocumentQuery(UriFactory.CreateDocumentCollectionUri("db", "coll"), queryString).AsDocumentQuery();

     double totalRequestCharge = 0;
     while (queryable.HasMoreResults)
     {
        FeedResponse<dynamic> queryResponse = await queryable.ExecuteNextAsync<dynamic>(); 
        Console.WriteLine("Query batch consumed {0} request units",queryResponse.RequestCharge);
        totalRequestCharge += queryResponse.RequestCharge;
     }

     Console.WriteLine("Query consumed {0} request units in total", totalRequestCharge);

## <a name="changes-to-the-indexing-policy-specification"></a><span data-ttu-id="86871-351">Changes to the indexing policy specification</span><span class="sxs-lookup"><span data-stu-id="86871-351">Changes to the indexing policy specification</span></span>
<span data-ttu-id="86871-352">A change in the schema for indexing policy was introduced on July 7, 2015 with REST API version 2015-06-03.</span><span class="sxs-lookup"><span data-stu-id="86871-352">A change in the schema for indexing policy was introduced on July 7, 2015 with REST API version 2015-06-03.</span></span> <span data-ttu-id="86871-353">The corresponding classes in the SDK versions have new implementations to match the schema.</span><span class="sxs-lookup"><span data-stu-id="86871-353">The corresponding classes in the SDK versions have new implementations to match the schema.</span></span> 

<span data-ttu-id="86871-354">The following changes were implemented in the JSON specification:</span><span class="sxs-lookup"><span data-stu-id="86871-354">The following changes were implemented in the JSON specification:</span></span>

* <span data-ttu-id="86871-355">Indexing Policy supports Range indexes for strings</span><span class="sxs-lookup"><span data-stu-id="86871-355">Indexing Policy supports Range indexes for strings</span></span>
* <span data-ttu-id="86871-356">Each path can have multiple index definitions, one for each data type</span><span class="sxs-lookup"><span data-stu-id="86871-356">Each path can have multiple index definitions, one for each data type</span></span>
* <span data-ttu-id="86871-357">Indexing precision supports 1-8 for numbers, 1-100 for strings, and -1 (maximum precision)</span><span class="sxs-lookup"><span data-stu-id="86871-357">Indexing precision supports 1-8 for numbers, 1-100 for strings, and -1 (maximum precision)</span></span>
* <span data-ttu-id="86871-358">Paths segments do not require a double quotation to escape each path.</span><span class="sxs-lookup"><span data-stu-id="86871-358">Paths segments do not require a double quotation to escape each path.</span></span> <span data-ttu-id="86871-359">For example, you can add a path for /title/?</span><span class="sxs-lookup"><span data-stu-id="86871-359">For example, you can add a path for /title/?</span></span> <span data-ttu-id="86871-360">instead of /"title"/?</span><span class="sxs-lookup"><span data-stu-id="86871-360">instead of /"title"/?</span></span>
* <span data-ttu-id="86871-361">The root path representing "all paths" can be represented as /\* (in addition to /)</span><span class="sxs-lookup"><span data-stu-id="86871-361">The root path representing "all paths" can be represented as /\* (in addition to /)</span></span>

<span data-ttu-id="86871-362">If you have code that provisions collections with a custom indexing policy written with version 1.1.0 of the .NET SDK or older, you will need to change your application code to handle these changes in order to move to SDK version 1.2.0.</span><span class="sxs-lookup"><span data-stu-id="86871-362">If you have code that provisions collections with a custom indexing policy written with version 1.1.0 of the .NET SDK or older, you will need to change your application code to handle these changes in order to move to SDK version 1.2.0.</span></span> <span data-ttu-id="86871-363">If you do not have code that configures indexing policy, or plan to continue using an older SDK version, no changes are required.</span><span class="sxs-lookup"><span data-stu-id="86871-363">If you do not have code that configures indexing policy, or plan to continue using an older SDK version, no changes are required.</span></span>

<span data-ttu-id="86871-364">For a practical comparison, here is one example custom indexing policy written using the REST API version 2015-06-03 as well as the previous version 2015-04-08.</span><span class="sxs-lookup"><span data-stu-id="86871-364">For a practical comparison, here is one example custom indexing policy written using the REST API version 2015-06-03 as well as the previous version 2015-04-08.</span></span>

<span data-ttu-id="86871-365">**Previous Indexing Policy JSON**</span><span class="sxs-lookup"><span data-stu-id="86871-365">**Previous Indexing Policy JSON**</span></span>

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "IncludedPaths":[
          {
             "IndexType":"Hash",
             "Path":"/",
             "NumericPrecision":7,
             "StringPrecision":3
          }
       ],
       "ExcludedPaths":[
          "/\"nonIndexedContent\"/*"
       ]
    }

<span data-ttu-id="86871-366">**Current Indexing Policy JSON**</span><span class="sxs-lookup"><span data-stu-id="86871-366">**Current Indexing Policy JSON**</span></span>

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "includedPaths":[
          {
             "path":"/*",
             "indexes":[
                {
                   "kind":"Hash",
                   "dataType":"String",
                   "precision":3
                },
                {
                   "kind":"Hash",
                   "dataType":"Number",
                   "precision":7
                }
             ]
          }
       ],
       "ExcludedPaths":[
          {
             "path":"/nonIndexedContent/*"
          }
       ]
    }

## <a name="next-steps"></a><span data-ttu-id="86871-367">Next Steps</span><span class="sxs-lookup"><span data-stu-id="86871-367">Next Steps</span></span>
<span data-ttu-id="86871-368">Follow the links below for index policy management samples and to learn more about DocumentDB's query language.</span><span class="sxs-lookup"><span data-stu-id="86871-368">Follow the links below for index policy management samples and to learn more about DocumentDB's query language.</span></span>

1. [<span data-ttu-id="86871-369">DocumentDB .NET Index Management code samples</span><span class="sxs-lookup"><span data-stu-id="86871-369">DocumentDB .NET Index Management code samples</span></span>](https://github.com/Azure/azure-documentdb-net/blob/master/samples/code-samples/IndexManagement/Program.cs)
2. [<span data-ttu-id="86871-370">DocumentDB REST API Collection Operations</span><span class="sxs-lookup"><span data-stu-id="86871-370">DocumentDB REST API Collection Operations</span></span>](https://msdn.microsoft.com/library/azure/dn782195.aspx)
3. [<span data-ttu-id="86871-371">Query with DocumentDB SQL</span><span class="sxs-lookup"><span data-stu-id="86871-371">Query with DocumentDB SQL</span></span>](documentdb-sql-query.md)


