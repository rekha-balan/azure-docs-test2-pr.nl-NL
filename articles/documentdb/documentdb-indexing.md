---
redirect_url: https://azure.microsoft.com/services/documentdb/
ROBOTS: NOINDEX, NOFOLLOW
ms.openlocfilehash: 83d30beaa8ecd30f8ca0e9d1418a70743d576b9a
ms.sourcegitcommit: 5b9d839c0c0a94b293fdafe1d6e5429506c07e05
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 08/02/2018
ms.locfileid: "44550460"
---
# <a name="automatic-indexing-in-azure-documentdb"></a><span data-ttu-id="c9916-101">Automatic indexing in Azure DocumentDB</span><span class="sxs-lookup"><span data-stu-id="c9916-101">Automatic indexing in Azure DocumentDB</span></span>
<span data-ttu-id="c9916-102">This article is excerpted from the ["Schema-Agnostic Indexing with Azure DocumentDB"](http://www.vldb.org/pvldb/vol8/p1668-shukla.pdf) paper, which will be presented at the [41st Internal Conference on Very Large Databases](http://www.vldb.org/2015/) between August 31 - September 4, 2015, and is an introduction into how indexing works in Azure DocumentDB.</span><span class="sxs-lookup"><span data-stu-id="c9916-102">This article is excerpted from the ["Schema-Agnostic Indexing with Azure DocumentDB"](http://www.vldb.org/pvldb/vol8/p1668-shukla.pdf) paper, which will be presented at the [41st Internal Conference on Very Large Databases](http://www.vldb.org/2015/) between August 31 - September 4, 2015, and is an introduction into how indexing works in Azure DocumentDB.</span></span> 

<span data-ttu-id="c9916-103">After reading this, you will be answer the following questions:</span><span class="sxs-lookup"><span data-stu-id="c9916-103">After reading this, you will be answer the following questions:</span></span>

* <span data-ttu-id="c9916-104">How does DocumentDB infer the schema from a JSON document?</span><span class="sxs-lookup"><span data-stu-id="c9916-104">How does DocumentDB infer the schema from a JSON document?</span></span>
* <span data-ttu-id="c9916-105">How does DocumentDB build an index across disparate documents?</span><span class="sxs-lookup"><span data-stu-id="c9916-105">How does DocumentDB build an index across disparate documents?</span></span>
* <span data-ttu-id="c9916-106">How does DocumentDB perform automatic indexing at scale?</span><span class="sxs-lookup"><span data-stu-id="c9916-106">How does DocumentDB perform automatic indexing at scale?</span></span>

## <a id="HowDocumentDBIndexingWorks"></a> <span data-ttu-id="c9916-107">How DocumentDB indexing works</span><span class="sxs-lookup"><span data-stu-id="c9916-107">How DocumentDB indexing works</span></span>
<span data-ttu-id="c9916-108">[Microsoft Azure DocumentDB](https://azure.microsoft.com/services/documentdb/) is a true schema-free database purpose built for JSON.</span><span class="sxs-lookup"><span data-stu-id="c9916-108">[Microsoft Azure DocumentDB](https://azure.microsoft.com/services/documentdb/) is a true schema-free database purpose built for JSON.</span></span> <span data-ttu-id="c9916-109">It does not expect or require any schema or secondary index definitions to index data at scale.</span><span class="sxs-lookup"><span data-stu-id="c9916-109">It does not expect or require any schema or secondary index definitions to index data at scale.</span></span> <span data-ttu-id="c9916-110">This allows you to quickly define and iterate on application data models using DocumentDB.</span><span class="sxs-lookup"><span data-stu-id="c9916-110">This allows you to quickly define and iterate on application data models using DocumentDB.</span></span> <span data-ttu-id="c9916-111">As you add documents to a collection, DocumentDB automatically indexes all document properties so they are available for you to query.</span><span class="sxs-lookup"><span data-stu-id="c9916-111">As you add documents to a collection, DocumentDB automatically indexes all document properties so they are available for you to query.</span></span> <span data-ttu-id="c9916-112">Automatic indexing allows you to store documents belonging to completely arbitrary schemas without worrying about schemas or secondary indexes.</span><span class="sxs-lookup"><span data-stu-id="c9916-112">Automatic indexing allows you to store documents belonging to completely arbitrary schemas without worrying about schemas or secondary indexes.</span></span>

<span data-ttu-id="c9916-113">With a goal to eliminate the impedance mismatch between the database and the application programming models, DocumentDB exploits the simplicity of JSON and its lack of a schema specification.</span><span class="sxs-lookup"><span data-stu-id="c9916-113">With a goal to eliminate the impedance mismatch between the database and the application programming models, DocumentDB exploits the simplicity of JSON and its lack of a schema specification.</span></span> <span data-ttu-id="c9916-114">It makes no assumptions about the documents and allows documents within a DocumentDB collection to vary in schema, in addition to the instance specific values.</span><span class="sxs-lookup"><span data-stu-id="c9916-114">It makes no assumptions about the documents and allows documents within a DocumentDB collection to vary in schema, in addition to the instance specific values.</span></span> <span data-ttu-id="c9916-115">In contrast to other document databases, DocumentDB’s database engine operates directly at the level of JSON grammar, remaining agnostic to the concept of a document schema and blurring the boundary between the structure and instance values of documents.</span><span class="sxs-lookup"><span data-stu-id="c9916-115">In contrast to other document databases, DocumentDB’s database engine operates directly at the level of JSON grammar, remaining agnostic to the concept of a document schema and blurring the boundary between the structure and instance values of documents.</span></span> <span data-ttu-id="c9916-116">This, in-turn, enables it to automatically index documents without requiring schema or secondary indexes.</span><span class="sxs-lookup"><span data-stu-id="c9916-116">This, in-turn, enables it to automatically index documents without requiring schema or secondary indexes.</span></span>

<span data-ttu-id="c9916-117">The indexing in DocumentDB takes advantage of the fact that JSON grammar allows documents to be **represented as trees**.</span><span class="sxs-lookup"><span data-stu-id="c9916-117">The indexing in DocumentDB takes advantage of the fact that JSON grammar allows documents to be **represented as trees**.</span></span> <span data-ttu-id="c9916-118">For a JSON document to be represented as a tree, a dummy root node needs to be created which parents the rest of the actual nodes in the document underneath.</span><span class="sxs-lookup"><span data-stu-id="c9916-118">For a JSON document to be represented as a tree, a dummy root node needs to be created which parents the rest of the actual nodes in the document underneath.</span></span> <span data-ttu-id="c9916-119">Each label including the array indices in a JSON document becomes a node of the tree.</span><span class="sxs-lookup"><span data-stu-id="c9916-119">Each label including the array indices in a JSON document becomes a node of the tree.</span></span> <span data-ttu-id="c9916-120">The figure below illustrates an example JSON document and its corresponding tree representation.</span><span class="sxs-lookup"><span data-stu-id="c9916-120">The figure below illustrates an example JSON document and its corresponding tree representation.</span></span>

> [!NOTE]
> <span data-ttu-id="c9916-121">Since JSON is self-describing i.e. each document includes both schema (metadata) and data, e.g. `{"locationId": 5, "city": "Moscow"}` reveals that there are two properties `locationId` and `city`, and that they have a numeric and string property values.</span><span class="sxs-lookup"><span data-stu-id="c9916-121">Since JSON is self-describing i.e. each document includes both schema (metadata) and data, e.g. `{"locationId": 5, "city": "Moscow"}` reveals that there are two properties `locationId` and `city`, and that they have a numeric and string property values.</span></span> <span data-ttu-id="c9916-122">DocumentDB is able to infer the schema of documents and index them when they are inserted or replaced, without you ever having to define schemas or secondary indexes.</span><span class="sxs-lookup"><span data-stu-id="c9916-122">DocumentDB is able to infer the schema of documents and index them when they are inserted or replaced, without you ever having to define schemas or secondary indexes.</span></span>
> 
> 

<span data-ttu-id="c9916-123">**JSON Documents as Trees:**</span><span class="sxs-lookup"><span data-stu-id="c9916-123">**JSON Documents as Trees:**</span></span>

![Documents as Trees](https://docstestmedia1.blob.core.windows.net/azure-media/articles/documentdb/media/documentdb-indexing/DocumentsAsTrees.png)

<span data-ttu-id="c9916-125">For example, in the example shown above:</span><span class="sxs-lookup"><span data-stu-id="c9916-125">For example, in the example shown above:</span></span>

* <span data-ttu-id="c9916-126">The JSON property `{"headquarters": "Belgium"}` property in the above example corresponds to the path/headquarters/Belgium.</span><span class="sxs-lookup"><span data-stu-id="c9916-126">The JSON property `{"headquarters": "Belgium"}` property in the above example corresponds to the path/headquarters/Belgium.</span></span>
* <span data-ttu-id="c9916-127">The JSON array `{"exports": [{"city": “Moscow"}`, `{"city": Athens"}]}` corresponds to the paths `/exports/[]/city/Moscow` and `/exports/[]/city/Athens`.</span><span class="sxs-lookup"><span data-stu-id="c9916-127">The JSON array `{"exports": [{"city": “Moscow"}`, `{"city": Athens"}]}` corresponds to the paths `/exports/[]/city/Moscow` and `/exports/[]/city/Athens`.</span></span>

<span data-ttu-id="c9916-128">With automatic indexing, (1) every path in a document tree is indexed (unless the developer has explicitly configured the indexing policy to exclude certain path patterns).</span><span class="sxs-lookup"><span data-stu-id="c9916-128">With automatic indexing, (1) every path in a document tree is indexed (unless the developer has explicitly configured the indexing policy to exclude certain path patterns).</span></span> <span data-ttu-id="c9916-129">(2) Each update of a document to a DocumentDB collection leads to update of the structure of the index (i.e., causes addition or removal of nodes).</span><span class="sxs-lookup"><span data-stu-id="c9916-129">(2) Each update of a document to a DocumentDB collection leads to update of the structure of the index (i.e., causes addition or removal of nodes).</span></span> <span data-ttu-id="c9916-130">One of the primary requirements of automatic indexing of documents is to ensure that the cost to index and query a document with deeply nested structure, say 10 levels, is the same as that of a flat JSON document consisting of key-value pairs just one level deep.</span><span class="sxs-lookup"><span data-stu-id="c9916-130">One of the primary requirements of automatic indexing of documents is to ensure that the cost to index and query a document with deeply nested structure, say 10 levels, is the same as that of a flat JSON document consisting of key-value pairs just one level deep.</span></span> <span data-ttu-id="c9916-131">Therefore a normalized path representation is the foundation upon which both automatic indexing and query subsystems are built.</span><span class="sxs-lookup"><span data-stu-id="c9916-131">Therefore a normalized path representation is the foundation upon which both automatic indexing and query subsystems are built.</span></span>

<span data-ttu-id="c9916-132">An important implication of treating both the schema and instance values uniformly in terms of paths is that logically, just like the individual documents, an index of the two documents shown that keeps a map between paths and the document ids containing that path can also be represented as a tree.</span><span class="sxs-lookup"><span data-stu-id="c9916-132">An important implication of treating both the schema and instance values uniformly in terms of paths is that logically, just like the individual documents, an index of the two documents shown that keeps a map between paths and the document ids containing that path can also be represented as a tree.</span></span> <span data-ttu-id="c9916-133">DocumentDB uses this fact to build an index tree which is constructed out of the union of all of the trees representing individual documents within the collection.</span><span class="sxs-lookup"><span data-stu-id="c9916-133">DocumentDB uses this fact to build an index tree which is constructed out of the union of all of the trees representing individual documents within the collection.</span></span> <span data-ttu-id="c9916-134">The index tree in DocumentDB collections grows over time as new documents get added or updated to the collection.</span><span class="sxs-lookup"><span data-stu-id="c9916-134">The index tree in DocumentDB collections grows over time as new documents get added or updated to the collection.</span></span>

<span data-ttu-id="c9916-135">**DocumentDB Index as a Tree:**</span><span class="sxs-lookup"><span data-stu-id="c9916-135">**DocumentDB Index as a Tree:**</span></span>

![Index as a Tree](https://docstestmedia1.blob.core.windows.net/azure-media/articles/documentdb/media/documentdb-indexing/IndexAsTree.png)

<span data-ttu-id="c9916-137">Despite being schema-free, DocumentDB’s SQL and JavaScript query languages provide relational projections and filters, hierarchical navigation across documents, spatial operations, and invocation of UDFs written entirely in JavaScript.</span><span class="sxs-lookup"><span data-stu-id="c9916-137">Despite being schema-free, DocumentDB’s SQL and JavaScript query languages provide relational projections and filters, hierarchical navigation across documents, spatial operations, and invocation of UDFs written entirely in JavaScript.</span></span> <span data-ttu-id="c9916-138">The DocumentDB’s query runtime is able to support these queries since it can operate directly against this index tree representation of the data.</span><span class="sxs-lookup"><span data-stu-id="c9916-138">The DocumentDB’s query runtime is able to support these queries since it can operate directly against this index tree representation of the data.</span></span>

<span data-ttu-id="c9916-139">The default indexing policy automatically indexes all properties of all documents and provides consistent queries (meaning the index is updated synchronously with the document write).</span><span class="sxs-lookup"><span data-stu-id="c9916-139">The default indexing policy automatically indexes all properties of all documents and provides consistent queries (meaning the index is updated synchronously with the document write).</span></span> <span data-ttu-id="c9916-140">How does DocumentDB support consistent updates to the index tree at scale?</span><span class="sxs-lookup"><span data-stu-id="c9916-140">How does DocumentDB support consistent updates to the index tree at scale?</span></span> <span data-ttu-id="c9916-141">DocumentDB uses write optimized, lock free, and log structured index maintenance techniques.</span><span class="sxs-lookup"><span data-stu-id="c9916-141">DocumentDB uses write optimized, lock free, and log structured index maintenance techniques.</span></span> <span data-ttu-id="c9916-142">This means that DocumentDB can support a sustained volume of fast writes while still serving consistent queries.</span><span class="sxs-lookup"><span data-stu-id="c9916-142">This means that DocumentDB can support a sustained volume of fast writes while still serving consistent queries.</span></span> 

<span data-ttu-id="c9916-143">DocumentDB’s indexing is designed for storage efficiency and to handle multi-tenancy.</span><span class="sxs-lookup"><span data-stu-id="c9916-143">DocumentDB’s indexing is designed for storage efficiency and to handle multi-tenancy.</span></span> <span data-ttu-id="c9916-144">For cost effectiveness, the on-disk storage overhead of the index is low and predictable.</span><span class="sxs-lookup"><span data-stu-id="c9916-144">For cost effectiveness, the on-disk storage overhead of the index is low and predictable.</span></span> <span data-ttu-id="c9916-145">Index updates are also performed within the budget of system resources allocated per DocumentDB collection.</span><span class="sxs-lookup"><span data-stu-id="c9916-145">Index updates are also performed within the budget of system resources allocated per DocumentDB collection.</span></span>

## <a name="NextSteps"></a> <span data-ttu-id="c9916-146">Next steps</span><span class="sxs-lookup"><span data-stu-id="c9916-146">Next steps</span></span>
* <span data-ttu-id="c9916-147">Download ["Schema-Agnostic Indexing with Azure DocumentDB"](http://www.vldb.org/pvldb/vol8/p1668-shukla.pdf), to be presented at the 41st Internal Conference on Very Large Databases, August 31 - September 4, 2015.</span><span class="sxs-lookup"><span data-stu-id="c9916-147">Download ["Schema-Agnostic Indexing with Azure DocumentDB"](http://www.vldb.org/pvldb/vol8/p1668-shukla.pdf), to be presented at the 41st Internal Conference on Very Large Databases, August 31 - September 4, 2015.</span></span>
* [<span data-ttu-id="c9916-148">Query with DocumentDB SQL</span><span class="sxs-lookup"><span data-stu-id="c9916-148">Query with DocumentDB SQL</span></span>](documentdb-sql-query.md)
* <span data-ttu-id="c9916-149">Learn about how to customize the DocumentDB index [here](documentdb-indexing-policies.md)</span><span class="sxs-lookup"><span data-stu-id="c9916-149">Learn about how to customize the DocumentDB index [here](documentdb-indexing-policies.md)</span></span>



