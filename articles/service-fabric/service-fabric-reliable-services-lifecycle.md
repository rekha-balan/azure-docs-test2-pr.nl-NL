---
title: Overview of the lifecycle of Azure Service Fabric Reliable Services | Microsoft Docs
description: Learn about the different lifecycle events in Service Fabric Reliable Services
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: ''
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: conceptual
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 6aae6aba745d2c51dabd75c04c4164384ce11a26
ms.sourcegitcommit: d1451406a010fd3aa854dc8e5b77dc5537d8050e
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 09/13/2018
ms.locfileid: "44827782"
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="08e40-103">Reliable Services lifecycle overview</span><span class="sxs-lookup"><span data-stu-id="08e40-103">Reliable Services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [C# on Windows](service-fabric-reliable-services-lifecycle.md)
> * [Java on Linux](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="08e40-106">When you're thinking about the lifecycles of Azure Service Fabric Reliable Services, the basics of the lifecycle are the most important.</span><span class="sxs-lookup"><span data-stu-id="08e40-106">When you're thinking about the lifecycles of Azure Service Fabric Reliable Services, the basics of the lifecycle are the most important.</span></span> <span data-ttu-id="08e40-107">In general, the lifecycle includes the following:</span><span class="sxs-lookup"><span data-stu-id="08e40-107">In general, the lifecycle includes the following:</span></span>

- <span data-ttu-id="08e40-108">During startup:</span><span class="sxs-lookup"><span data-stu-id="08e40-108">During startup:</span></span>
  - <span data-ttu-id="08e40-109">Services are constructed.</span><span class="sxs-lookup"><span data-stu-id="08e40-109">Services are constructed.</span></span>
  - <span data-ttu-id="08e40-110">The services have an opportunity to construct and return zero or more listeners.</span><span class="sxs-lookup"><span data-stu-id="08e40-110">The services have an opportunity to construct and return zero or more listeners.</span></span>
  - <span data-ttu-id="08e40-111">Any returned listeners are opened, allowing communication with the service.</span><span class="sxs-lookup"><span data-stu-id="08e40-111">Any returned listeners are opened, allowing communication with the service.</span></span>
  - <span data-ttu-id="08e40-112">The service's **RunAsync** method is called, allowing the service to do long-running tasks or background work.</span><span class="sxs-lookup"><span data-stu-id="08e40-112">The service's **RunAsync** method is called, allowing the service to do long-running tasks or background work.</span></span>
- <span data-ttu-id="08e40-113">During shutdown:</span><span class="sxs-lookup"><span data-stu-id="08e40-113">During shutdown:</span></span>
  - <span data-ttu-id="08e40-114">The cancellation token passed to **RunAsync** is canceled, and the listeners are closed.</span><span class="sxs-lookup"><span data-stu-id="08e40-114">The cancellation token passed to **RunAsync** is canceled, and the listeners are closed.</span></span>
  - <span data-ttu-id="08e40-115">After the listeners close, the service object itself is destructed.</span><span class="sxs-lookup"><span data-stu-id="08e40-115">After the listeners close, the service object itself is destructed.</span></span>

<span data-ttu-id="08e40-116">There are details around the exact ordering of these events.</span><span class="sxs-lookup"><span data-stu-id="08e40-116">There are details around the exact ordering of these events.</span></span> <span data-ttu-id="08e40-117">The order of events can change slightly depending on whether the Reliable Service is stateless or stateful.</span><span class="sxs-lookup"><span data-stu-id="08e40-117">The order of events can change slightly depending on whether the Reliable Service is stateless or stateful.</span></span> <span data-ttu-id="08e40-118">In addition, for stateful services, we must deal with the Primary swap scenario.</span><span class="sxs-lookup"><span data-stu-id="08e40-118">In addition, for stateful services, we must deal with the Primary swap scenario.</span></span> <span data-ttu-id="08e40-119">During this sequence, the role of Primary is transferred to another replica (or comes back) without the service shutting down.</span><span class="sxs-lookup"><span data-stu-id="08e40-119">During this sequence, the role of Primary is transferred to another replica (or comes back) without the service shutting down.</span></span> <span data-ttu-id="08e40-120">Finally, we must think about error or failure conditions.</span><span class="sxs-lookup"><span data-stu-id="08e40-120">Finally, we must think about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="08e40-121">Stateless service startup</span><span class="sxs-lookup"><span data-stu-id="08e40-121">Stateless service startup</span></span>
<span data-ttu-id="08e40-122">The lifecycle of a stateless service is straightforward.</span><span class="sxs-lookup"><span data-stu-id="08e40-122">The lifecycle of a stateless service is straightforward.</span></span> <span data-ttu-id="08e40-123">Here's the order of events:</span><span class="sxs-lookup"><span data-stu-id="08e40-123">Here's the order of events:</span></span>

1. <span data-ttu-id="08e40-124">The service is constructed.</span><span class="sxs-lookup"><span data-stu-id="08e40-124">The service is constructed.</span></span>
2. <span data-ttu-id="08e40-125">Then, in parallel, two things happen:</span><span class="sxs-lookup"><span data-stu-id="08e40-125">Then, in parallel, two things happen:</span></span>
    - <span data-ttu-id="08e40-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are opened.</span><span class="sxs-lookup"><span data-stu-id="08e40-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are opened.</span></span> <span data-ttu-id="08e40-127">`ICommunicationListener.OpenAsync()` is called on each listener.</span><span class="sxs-lookup"><span data-stu-id="08e40-127">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="08e40-128">The service's `StatelessService.RunAsync()` method is called.</span><span class="sxs-lookup"><span data-stu-id="08e40-128">The service's `StatelessService.RunAsync()` method is called.</span></span>
3. <span data-ttu-id="08e40-129">If present, the service's `StatelessService.OnOpenAsync()` method is called.</span><span class="sxs-lookup"><span data-stu-id="08e40-129">If present, the service's `StatelessService.OnOpenAsync()` method is called.</span></span> <span data-ttu-id="08e40-130">This call is an uncommon override, but it is available.</span><span class="sxs-lookup"><span data-stu-id="08e40-130">This call is an uncommon override, but it is available.</span></span> <span data-ttu-id="08e40-131">Extended service initialization tasks can be started at this time.</span><span class="sxs-lookup"><span data-stu-id="08e40-131">Extended service initialization tasks can be started at this time.</span></span>

<span data-ttu-id="08e40-132">Keep in mind that there is no ordering between the calls to create and open the listeners and **RunAsync**.</span><span class="sxs-lookup"><span data-stu-id="08e40-132">Keep in mind that there is no ordering between the calls to create and open the listeners and **RunAsync**.</span></span> <span data-ttu-id="08e40-133">The listeners can open before **RunAsync** is started.</span><span class="sxs-lookup"><span data-stu-id="08e40-133">The listeners can open before **RunAsync** is started.</span></span> <span data-ttu-id="08e40-134">Similarly, you can invoke **RunAsync** before the communication listeners are open or even constructed.</span><span class="sxs-lookup"><span data-stu-id="08e40-134">Similarly, you can invoke **RunAsync** before the communication listeners are open or even constructed.</span></span> <span data-ttu-id="08e40-135">If any synchronization is required, it is left as an exercise to the implementer.</span><span class="sxs-lookup"><span data-stu-id="08e40-135">If any synchronization is required, it is left as an exercise to the implementer.</span></span> <span data-ttu-id="08e40-136">Here are some common solutions:</span><span class="sxs-lookup"><span data-stu-id="08e40-136">Here are some common solutions:</span></span>

  - <span data-ttu-id="08e40-137">Sometimes listeners can't function until some other information is created or work is done.</span><span class="sxs-lookup"><span data-stu-id="08e40-137">Sometimes listeners can't function until some other information is created or work is done.</span></span> <span data-ttu-id="08e40-138">For stateless services, that work can usually be done in other locations, such as the following:</span><span class="sxs-lookup"><span data-stu-id="08e40-138">For stateless services, that work can usually be done in other locations, such as the following:</span></span> 
    - <span data-ttu-id="08e40-139">In the service's constructor.</span><span class="sxs-lookup"><span data-stu-id="08e40-139">In the service's constructor.</span></span>
    - <span data-ttu-id="08e40-140">During the `CreateServiceInstanceListeners()` call.</span><span class="sxs-lookup"><span data-stu-id="08e40-140">During the `CreateServiceInstanceListeners()` call.</span></span>
    - <span data-ttu-id="08e40-141">As a part of the construction of the listener itself.</span><span class="sxs-lookup"><span data-stu-id="08e40-141">As a part of the construction of the listener itself.</span></span>
  - <span data-ttu-id="08e40-142">Sometimes the code in **RunAsync** doesn't start until the listeners are open.</span><span class="sxs-lookup"><span data-stu-id="08e40-142">Sometimes the code in **RunAsync** doesn't start until the listeners are open.</span></span> <span data-ttu-id="08e40-143">In this case, additional coordination is necessary.</span><span class="sxs-lookup"><span data-stu-id="08e40-143">In this case, additional coordination is necessary.</span></span> <span data-ttu-id="08e40-144">One common solution is that there is a flag within the listeners that indicates when they have finished.</span><span class="sxs-lookup"><span data-stu-id="08e40-144">One common solution is that there is a flag within the listeners that indicates when they have finished.</span></span> <span data-ttu-id="08e40-145">This flag is then checked in **RunAsync** before continuing to actual work.</span><span class="sxs-lookup"><span data-stu-id="08e40-145">This flag is then checked in **RunAsync** before continuing to actual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="08e40-146">Stateless service shutdown</span><span class="sxs-lookup"><span data-stu-id="08e40-146">Stateless service shutdown</span></span>
<span data-ttu-id="08e40-147">For shutting down a stateless service, the same pattern is followed, just in reverse:</span><span class="sxs-lookup"><span data-stu-id="08e40-147">For shutting down a stateless service, the same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="08e40-148">In parallel:</span><span class="sxs-lookup"><span data-stu-id="08e40-148">In parallel:</span></span>
    - <span data-ttu-id="08e40-149">Any open listeners are closed.</span><span class="sxs-lookup"><span data-stu-id="08e40-149">Any open listeners are closed.</span></span> <span data-ttu-id="08e40-150">`ICommunicationListener.CloseAsync()` is called on each listener.</span><span class="sxs-lookup"><span data-stu-id="08e40-150">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="08e40-151">The cancellation token passed to `RunAsync()` is canceled.</span><span class="sxs-lookup"><span data-stu-id="08e40-151">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="08e40-152">A check of the cancellation token's `IsCancellationRequested` property returns true, and if called, the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="08e40-152">A check of the cancellation token's `IsCancellationRequested` property returns true, and if called, the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="08e40-153">After `CloseAsync()` finishes on each listener and `RunAsync()` also finishes, the service's `StatelessService.OnCloseAsync()` method is called, if present.</span><span class="sxs-lookup"><span data-stu-id="08e40-153">After `CloseAsync()` finishes on each listener and `RunAsync()` also finishes, the service's `StatelessService.OnCloseAsync()` method is called, if present.</span></span>  <span data-ttu-id="08e40-154">OnCloseAsync is called when the stateless service instance is going to be gracefully shut down.</span><span class="sxs-lookup"><span data-stu-id="08e40-154">OnCloseAsync is called when the stateless service instance is going to be gracefully shut down.</span></span> <span data-ttu-id="08e40-155">This can occur when the service's code is being upgraded, the service instance is being moved due to load balancing, or a transient fault is detected.</span><span class="sxs-lookup"><span data-stu-id="08e40-155">This can occur when the service's code is being upgraded, the service instance is being moved due to load balancing, or a transient fault is detected.</span></span> <span data-ttu-id="08e40-156">It is uncommon to override `StatelessService.OnCloseAsync()`, but it  can be used to safely close resources, stop background processing, finish saving external state, or close down existing connections.</span><span class="sxs-lookup"><span data-stu-id="08e40-156">It is uncommon to override `StatelessService.OnCloseAsync()`, but it  can be used to safely close resources, stop background processing, finish saving external state, or close down existing connections.</span></span>
3. <span data-ttu-id="08e40-157">After `StatelessService.OnCloseAsync()` finishes, the service object is destructed.</span><span class="sxs-lookup"><span data-stu-id="08e40-157">After `StatelessService.OnCloseAsync()` finishes, the service object is destructed.</span></span>

## <a name="stateful-service-startup"></a><span data-ttu-id="08e40-158">Stateful service startup</span><span class="sxs-lookup"><span data-stu-id="08e40-158">Stateful service startup</span></span>
<span data-ttu-id="08e40-159">Stateful services have a similar pattern to stateless services, with a few changes.</span><span class="sxs-lookup"><span data-stu-id="08e40-159">Stateful services have a similar pattern to stateless services, with a few changes.</span></span> <span data-ttu-id="08e40-160">For starting up a stateful service, the order of events is as follows:</span><span class="sxs-lookup"><span data-stu-id="08e40-160">For starting up a stateful service, the order of events is as follows:</span></span>

1. <span data-ttu-id="08e40-161">The service is constructed.</span><span class="sxs-lookup"><span data-stu-id="08e40-161">The service is constructed.</span></span>
2. <span data-ttu-id="08e40-162">`StatefulServiceBase.OnOpenAsync()` is called.</span><span class="sxs-lookup"><span data-stu-id="08e40-162">`StatefulServiceBase.OnOpenAsync()` is called.</span></span> <span data-ttu-id="08e40-163">This call is not commonly overridden in the service.</span><span class="sxs-lookup"><span data-stu-id="08e40-163">This call is not commonly overridden in the service.</span></span>
3. <span data-ttu-id="08e40-164">The following things happen in parallel:</span><span class="sxs-lookup"><span data-stu-id="08e40-164">The following things happen in parallel:</span></span>
    - <span data-ttu-id="08e40-165">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked.</span><span class="sxs-lookup"><span data-stu-id="08e40-165">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked.</span></span> 
      - <span data-ttu-id="08e40-166">If the service is a Primary service, all returned listeners are opened.</span><span class="sxs-lookup"><span data-stu-id="08e40-166">If the service is a Primary service, all returned listeners are opened.</span></span> <span data-ttu-id="08e40-167">`ICommunicationListener.OpenAsync()` is called on each listener.</span><span class="sxs-lookup"><span data-stu-id="08e40-167">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
      - <span data-ttu-id="08e40-168">If the service is a Secondary service, only those listeners marked as `ListenOnSecondary = true` are opened.</span><span class="sxs-lookup"><span data-stu-id="08e40-168">If the service is a Secondary service, only those listeners marked as `ListenOnSecondary = true` are opened.</span></span> <span data-ttu-id="08e40-169">Having listeners that are open on secondaries is less common.</span><span class="sxs-lookup"><span data-stu-id="08e40-169">Having listeners that are open on secondaries is less common.</span></span>
    - <span data-ttu-id="08e40-170">If the service is currently a Primary, the service's `StatefulServiceBase.RunAsync()` method is called.</span><span class="sxs-lookup"><span data-stu-id="08e40-170">If the service is currently a Primary, the service's `StatefulServiceBase.RunAsync()` method is called.</span></span>
4. <span data-ttu-id="08e40-171">After all the replica listener's `OpenAsync()` calls finish and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span><span class="sxs-lookup"><span data-stu-id="08e40-171">After all the replica listener's `OpenAsync()` calls finish and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="08e40-172">This call is not commonly overridden in the service.</span><span class="sxs-lookup"><span data-stu-id="08e40-172">This call is not commonly overridden in the service.</span></span>

<span data-ttu-id="08e40-173">Similar to stateless services, there's no coordination between the order in which the listeners are created and opened and when **RunAsync** is called.</span><span class="sxs-lookup"><span data-stu-id="08e40-173">Similar to stateless services, there's no coordination between the order in which the listeners are created and opened and when **RunAsync** is called.</span></span> <span data-ttu-id="08e40-174">If you need coordination, the solutions are much the same.</span><span class="sxs-lookup"><span data-stu-id="08e40-174">If you need coordination, the solutions are much the same.</span></span> <span data-ttu-id="08e40-175">There is one additional case for stateful service.</span><span class="sxs-lookup"><span data-stu-id="08e40-175">There is one additional case for stateful service.</span></span> <span data-ttu-id="08e40-176">Say that the calls that arrive at the communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="08e40-176">Say that the calls that arrive at the communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span>

   > [!NOTE]  
   > Because the communication listeners could open before the reliable collections are readable or writeable, and before **RunAsync** could start, some additional coordination is necessary. The simplest and most common solution is for the communication listeners to return an error code that the client uses to know to retry the request.

## <a name="stateful-service-shutdown"></a><span data-ttu-id="08e40-179">Stateful service shutdown</span><span class="sxs-lookup"><span data-stu-id="08e40-179">Stateful service shutdown</span></span>
<span data-ttu-id="08e40-180">Like stateless services, the lifecycle events during shutdown are the same as during startup, but reversed.</span><span class="sxs-lookup"><span data-stu-id="08e40-180">Like stateless services, the lifecycle events during shutdown are the same as during startup, but reversed.</span></span> <span data-ttu-id="08e40-181">When a stateful service is being shut down, the following events occur:</span><span class="sxs-lookup"><span data-stu-id="08e40-181">When a stateful service is being shut down, the following events occur:</span></span>

1. <span data-ttu-id="08e40-182">In parallel:</span><span class="sxs-lookup"><span data-stu-id="08e40-182">In parallel:</span></span>
    - <span data-ttu-id="08e40-183">Any open listeners are closed.</span><span class="sxs-lookup"><span data-stu-id="08e40-183">Any open listeners are closed.</span></span> <span data-ttu-id="08e40-184">`ICommunicationListener.CloseAsync()` is called on each listener.</span><span class="sxs-lookup"><span data-stu-id="08e40-184">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="08e40-185">The cancellation token passed to `RunAsync()` is canceled.</span><span class="sxs-lookup"><span data-stu-id="08e40-185">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="08e40-186">A check of the cancellation token's `IsCancellationRequested` property returns true, and if called, the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="08e40-186">A check of the cancellation token's `IsCancellationRequested` property returns true, and if called, the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="08e40-187">After `CloseAsync()` finishes on each listener and `RunAsync()` also finishes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span><span class="sxs-lookup"><span data-stu-id="08e40-187">After `CloseAsync()` finishes on each listener and `RunAsync()` also finishes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="08e40-188">This call is not commonly overridden in the service.</span><span class="sxs-lookup"><span data-stu-id="08e40-188">This call is not commonly overridden in the service.</span></span>

   > [!NOTE]  
   > The need to wait for **RunAsync** to finish is only necessary if this replica is a Primary replica.

3. <span data-ttu-id="08e40-190">After the `StatefulServiceBase.OnChangeRoleAsync()` method finishes, the `StatefulServiceBase.OnCloseAsync()` method is called.</span><span class="sxs-lookup"><span data-stu-id="08e40-190">After the `StatefulServiceBase.OnChangeRoleAsync()` method finishes, the `StatefulServiceBase.OnCloseAsync()` method is called.</span></span> <span data-ttu-id="08e40-191">This call is an uncommon override, but it is available.</span><span class="sxs-lookup"><span data-stu-id="08e40-191">This call is an uncommon override, but it is available.</span></span>
3. <span data-ttu-id="08e40-192">After `StatefulServiceBase.OnCloseAsync()` finishes, the service object is destructed.</span><span class="sxs-lookup"><span data-stu-id="08e40-192">After `StatefulServiceBase.OnCloseAsync()` finishes, the service object is destructed.</span></span>

## <a name="stateful-service-primary-swaps"></a><span data-ttu-id="08e40-193">Stateful service Primary swaps</span><span class="sxs-lookup"><span data-stu-id="08e40-193">Stateful service Primary swaps</span></span>
<span data-ttu-id="08e40-194">While a stateful service is running, only the Primary replicas of that stateful services have their communication listeners opened and their **RunAsync** method called.</span><span class="sxs-lookup"><span data-stu-id="08e40-194">While a stateful service is running, only the Primary replicas of that stateful services have their communication listeners opened and their **RunAsync** method called.</span></span> <span data-ttu-id="08e40-195">Secondary replicas are constructed, but see no further calls.</span><span class="sxs-lookup"><span data-stu-id="08e40-195">Secondary replicas are constructed, but see no further calls.</span></span> <span data-ttu-id="08e40-196">While a stateful service is running, the replica that's currently the Primary can change.</span><span class="sxs-lookup"><span data-stu-id="08e40-196">While a stateful service is running, the replica that's currently the Primary can change.</span></span> <span data-ttu-id="08e40-197">What does this mean in terms of the lifecycle events that a replica can see?</span><span class="sxs-lookup"><span data-stu-id="08e40-197">What does this mean in terms of the lifecycle events that a replica can see?</span></span> <span data-ttu-id="08e40-198">The behavior the stateful replica sees depends on whether it is the replica being demoted or promoted during the swap.</span><span class="sxs-lookup"><span data-stu-id="08e40-198">The behavior the stateful replica sees depends on whether it is the replica being demoted or promoted during the swap.</span></span>

### <a name="for-the-primary-thats-demoted"></a><span data-ttu-id="08e40-199">For the Primary that's demoted</span><span class="sxs-lookup"><span data-stu-id="08e40-199">For the Primary that's demoted</span></span>
<span data-ttu-id="08e40-200">For the Primary replica that's demoted, Service Fabric needs this replica to stop processing messages and quit any background work it is doing.</span><span class="sxs-lookup"><span data-stu-id="08e40-200">For the Primary replica that's demoted, Service Fabric needs this replica to stop processing messages and quit any background work it is doing.</span></span> <span data-ttu-id="08e40-201">As a result, this step looks like it did when the service is shut down.</span><span class="sxs-lookup"><span data-stu-id="08e40-201">As a result, this step looks like it did when the service is shut down.</span></span> <span data-ttu-id="08e40-202">One difference is that the service isn't destructed or closed because it remains as a Secondary.</span><span class="sxs-lookup"><span data-stu-id="08e40-202">One difference is that the service isn't destructed or closed because it remains as a Secondary.</span></span> <span data-ttu-id="08e40-203">The following APIs are called:</span><span class="sxs-lookup"><span data-stu-id="08e40-203">The following APIs are called:</span></span>

1. <span data-ttu-id="08e40-204">In parallel:</span><span class="sxs-lookup"><span data-stu-id="08e40-204">In parallel:</span></span>
    - <span data-ttu-id="08e40-205">Any open listeners are closed.</span><span class="sxs-lookup"><span data-stu-id="08e40-205">Any open listeners are closed.</span></span> <span data-ttu-id="08e40-206">`ICommunicationListener.CloseAsync()` is called on each listener.</span><span class="sxs-lookup"><span data-stu-id="08e40-206">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="08e40-207">The cancellation token passed to `RunAsync()` is canceled.</span><span class="sxs-lookup"><span data-stu-id="08e40-207">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="08e40-208">A check of the cancellation token's `IsCancellationRequested` property returns true, and if called, the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="08e40-208">A check of the cancellation token's `IsCancellationRequested` property returns true, and if called, the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="08e40-209">After `CloseAsync()` finishes on each listener and `RunAsync()` also finishes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span><span class="sxs-lookup"><span data-stu-id="08e40-209">After `CloseAsync()` finishes on each listener and `RunAsync()` also finishes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="08e40-210">This call is not commonly overridden in the service.</span><span class="sxs-lookup"><span data-stu-id="08e40-210">This call is not commonly overridden in the service.</span></span>

### <a name="for-the-secondary-thats-promoted"></a><span data-ttu-id="08e40-211">For the Secondary that's promoted</span><span class="sxs-lookup"><span data-stu-id="08e40-211">For the Secondary that's promoted</span></span>
<span data-ttu-id="08e40-212">Similarly, Service Fabric needs the Secondary replica that's promoted to start listening for messages on the wire and start any background tasks it needs to complete.</span><span class="sxs-lookup"><span data-stu-id="08e40-212">Similarly, Service Fabric needs the Secondary replica that's promoted to start listening for messages on the wire and start any background tasks it needs to complete.</span></span> <span data-ttu-id="08e40-213">As a result, this process looks like it did when the service is created, except that the replica itself already exists.</span><span class="sxs-lookup"><span data-stu-id="08e40-213">As a result, this process looks like it did when the service is created, except that the replica itself already exists.</span></span> <span data-ttu-id="08e40-214">The following APIs are called:</span><span class="sxs-lookup"><span data-stu-id="08e40-214">The following APIs are called:</span></span>

1. <span data-ttu-id="08e40-215">In parallel:</span><span class="sxs-lookup"><span data-stu-id="08e40-215">In parallel:</span></span>
    - <span data-ttu-id="08e40-216">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are opened.</span><span class="sxs-lookup"><span data-stu-id="08e40-216">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are opened.</span></span> <span data-ttu-id="08e40-217">`ICommunicationListener.OpenAsync()` is called on each listener.</span><span class="sxs-lookup"><span data-stu-id="08e40-217">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="08e40-218">The service's `StatefulServiceBase.RunAsync()` method is called.</span><span class="sxs-lookup"><span data-stu-id="08e40-218">The service's `StatefulServiceBase.RunAsync()` method is called.</span></span>
2. <span data-ttu-id="08e40-219">After all the replica listener's `OpenAsync()` calls finish and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span><span class="sxs-lookup"><span data-stu-id="08e40-219">After all the replica listener's `OpenAsync()` calls finish and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="08e40-220">This call is not commonly overridden in the service.</span><span class="sxs-lookup"><span data-stu-id="08e40-220">This call is not commonly overridden in the service.</span></span>

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a><span data-ttu-id="08e40-221">Common issues during stateful service shutdown and Primary demotion</span><span class="sxs-lookup"><span data-stu-id="08e40-221">Common issues during stateful service shutdown and Primary demotion</span></span>
<span data-ttu-id="08e40-222">Service Fabric changes the Primary of a stateful service for a variety of reasons.</span><span class="sxs-lookup"><span data-stu-id="08e40-222">Service Fabric changes the Primary of a stateful service for a variety of reasons.</span></span> <span data-ttu-id="08e40-223">The most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span><span class="sxs-lookup"><span data-stu-id="08e40-223">The most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span></span> <span data-ttu-id="08e40-224">During these operations (as well as during normal service shutdown, like you'd see if the service was deleted), it is important that the service respect the `CancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="08e40-224">During these operations (as well as during normal service shutdown, like you'd see if the service was deleted), it is important that the service respect the `CancellationToken`.</span></span> 

<span data-ttu-id="08e40-225">Services that do not handle cancellation cleanly can experience several issues.</span><span class="sxs-lookup"><span data-stu-id="08e40-225">Services that do not handle cancellation cleanly can experience several issues.</span></span> <span data-ttu-id="08e40-226">These operations are slow because Service Fabric waits for the services to stop gracefully.</span><span class="sxs-lookup"><span data-stu-id="08e40-226">These operations are slow because Service Fabric waits for the services to stop gracefully.</span></span> <span data-ttu-id="08e40-227">This can ultimately lead to failed upgrades that time out and roll back.</span><span class="sxs-lookup"><span data-stu-id="08e40-227">This can ultimately lead to failed upgrades that time out and roll back.</span></span> <span data-ttu-id="08e40-228">Failure to honor the cancellation token can also cause imbalanced clusters.</span><span class="sxs-lookup"><span data-stu-id="08e40-228">Failure to honor the cancellation token can also cause imbalanced clusters.</span></span> <span data-ttu-id="08e40-229">Clusters become unbalanced because nodes get hot, but the services can't be rebalanced because it takes too long to move them elsewhere.</span><span class="sxs-lookup"><span data-stu-id="08e40-229">Clusters become unbalanced because nodes get hot, but the services can't be rebalanced because it takes too long to move them elsewhere.</span></span> 

<span data-ttu-id="08e40-230">Because the services are stateful, it is also likely that they use the [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="08e40-230">Because the services are stateful, it is also likely that they use the [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="08e40-231">In Service Fabric, when a Primary is demoted, one of the first things that happens is that write access to the underlying state is revoked.</span><span class="sxs-lookup"><span data-stu-id="08e40-231">In Service Fabric, when a Primary is demoted, one of the first things that happens is that write access to the underlying state is revoked.</span></span> <span data-ttu-id="08e40-232">This leads to a second set of issues that can affect the service lifecycle.</span><span class="sxs-lookup"><span data-stu-id="08e40-232">This leads to a second set of issues that can affect the service lifecycle.</span></span> <span data-ttu-id="08e40-233">The collections return exceptions based on the timing and whether the replica is being moved or shut down.</span><span class="sxs-lookup"><span data-stu-id="08e40-233">The collections return exceptions based on the timing and whether the replica is being moved or shut down.</span></span> <span data-ttu-id="08e40-234">These exceptions should be handled correctly.</span><span class="sxs-lookup"><span data-stu-id="08e40-234">These exceptions should be handled correctly.</span></span> <span data-ttu-id="08e40-235">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span><span class="sxs-lookup"><span data-stu-id="08e40-235">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span></span> <span data-ttu-id="08e40-236">Permanent exceptions should be logged and thrown while the transient exceptions can be retried based on some retry logic.</span><span class="sxs-lookup"><span data-stu-id="08e40-236">Permanent exceptions should be logged and thrown while the transient exceptions can be retried based on some retry logic.</span></span>

<span data-ttu-id="08e40-237">Handling the exceptions that come from use of the `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span><span class="sxs-lookup"><span data-stu-id="08e40-237">Handling the exceptions that come from use of the `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span></span> <span data-ttu-id="08e40-238">We recommend that you always run your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before deploying to production.</span><span class="sxs-lookup"><span data-stu-id="08e40-238">We recommend that you always run your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before deploying to production.</span></span> <span data-ttu-id="08e40-239">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span><span class="sxs-lookup"><span data-stu-id="08e40-239">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span></span>


## <a name="notes-on-the-service-lifecycle"></a><span data-ttu-id="08e40-240">Notes on the service lifecycle</span><span class="sxs-lookup"><span data-stu-id="08e40-240">Notes on the service lifecycle</span></span>
  - <span data-ttu-id="08e40-241">Both the `RunAsync()` method and the `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span><span class="sxs-lookup"><span data-stu-id="08e40-241">Both the `RunAsync()` method and the `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="08e40-242">A service can have one of them, both, or neither.</span><span class="sxs-lookup"><span data-stu-id="08e40-242">A service can have one of them, both, or neither.</span></span> <span data-ttu-id="08e40-243">For example, if the service does all its work in response to user calls, there is no need for it to implement `RunAsync()`.</span><span class="sxs-lookup"><span data-stu-id="08e40-243">For example, if the service does all its work in response to user calls, there is no need for it to implement `RunAsync()`.</span></span> <span data-ttu-id="08e40-244">Only the communication listeners and their associated code are necessary.</span><span class="sxs-lookup"><span data-stu-id="08e40-244">Only the communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="08e40-245">Similarly, creating and returning communication listeners is optional, as the service can have only background work to do, and so only needs to implement `RunAsync()`.</span><span class="sxs-lookup"><span data-stu-id="08e40-245">Similarly, creating and returning communication listeners is optional, as the service can have only background work to do, and so only needs to implement `RunAsync()`.</span></span>
  - <span data-ttu-id="08e40-246">It is valid for a service to complete `RunAsync()` successfully and return from it.</span><span class="sxs-lookup"><span data-stu-id="08e40-246">It is valid for a service to complete `RunAsync()` successfully and return from it.</span></span> <span data-ttu-id="08e40-247">Completing is not a failure condition.</span><span class="sxs-lookup"><span data-stu-id="08e40-247">Completing is not a failure condition.</span></span> <span data-ttu-id="08e40-248">Completing `RunAsync()` indicates that the background work of the service has finished.</span><span class="sxs-lookup"><span data-stu-id="08e40-248">Completing `RunAsync()` indicates that the background work of the service has finished.</span></span> <span data-ttu-id="08e40-249">For stateful reliable services, `RunAsync()` is called again if the replica is demoted from Primary to Secondary and then promoted back to Primary.</span><span class="sxs-lookup"><span data-stu-id="08e40-249">For stateful reliable services, `RunAsync()` is called again if the replica is demoted from Primary to Secondary and then promoted back to Primary.</span></span>
  - <span data-ttu-id="08e40-250">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span><span class="sxs-lookup"><span data-stu-id="08e40-250">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span></span> <span data-ttu-id="08e40-251">The service object is shut down and a health error is reported.</span><span class="sxs-lookup"><span data-stu-id="08e40-251">The service object is shut down and a health error is reported.</span></span>
  - <span data-ttu-id="08e40-252">Although there is no time limit on returning from these methods, you immediately lose the ability to write to Reliable Collections, and therefore, cannot complete any real work.</span><span class="sxs-lookup"><span data-stu-id="08e40-252">Although there is no time limit on returning from these methods, you immediately lose the ability to write to Reliable Collections, and therefore, cannot complete any real work.</span></span> <span data-ttu-id="08e40-253">We recommended that you return as quickly as possible upon receiving the cancellation request.</span><span class="sxs-lookup"><span data-stu-id="08e40-253">We recommended that you return as quickly as possible upon receiving the cancellation request.</span></span> <span data-ttu-id="08e40-254">If your service does not respond to these API calls in a reasonable amount of time, Service Fabric can forcibly terminate your service.</span><span class="sxs-lookup"><span data-stu-id="08e40-254">If your service does not respond to these API calls in a reasonable amount of time, Service Fabric can forcibly terminate your service.</span></span> <span data-ttu-id="08e40-255">Usually this only happens during application upgrades or when a service is being deleted.</span><span class="sxs-lookup"><span data-stu-id="08e40-255">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="08e40-256">This timeout is 15 minutes by default.</span><span class="sxs-lookup"><span data-stu-id="08e40-256">This timeout is 15 minutes by default.</span></span>
  - <span data-ttu-id="08e40-257">Failures in the `OnCloseAsync()` path result in `OnAbort()` being called, which is a last-chance best-effort opportunity for the service to clean up and release any resources that they have claimed.</span><span class="sxs-lookup"><span data-stu-id="08e40-257">Failures in the `OnCloseAsync()` path result in `OnAbort()` being called, which is a last-chance best-effort opportunity for the service to clean up and release any resources that they have claimed.</span></span> <span data-ttu-id="08e40-258">This is generally called when a permanent fault is detected on the node, or when Service Fabric cannot reliably manage the service instance's lifecycle due to internal failures.</span><span class="sxs-lookup"><span data-stu-id="08e40-258">This is generally called when a permanent fault is detected on the node, or when Service Fabric cannot reliably manage the service instance's lifecycle due to internal failures.</span></span>
  - <span data-ttu-id="08e40-259">`OnChangeRoleAsync()` is called when the stateful service replica is changing role, for example to primary or secondary.</span><span class="sxs-lookup"><span data-stu-id="08e40-259">`OnChangeRoleAsync()` is called when the stateful service replica is changing role, for example to primary or secondary.</span></span> <span data-ttu-id="08e40-260">Primary replicas are given write status (are allowed to create and write to Reliable Collections).</span><span class="sxs-lookup"><span data-stu-id="08e40-260">Primary replicas are given write status (are allowed to create and write to Reliable Collections).</span></span> <span data-ttu-id="08e40-261">Secondary replicas are given read status (can only read from existing Reliable Collections).</span><span class="sxs-lookup"><span data-stu-id="08e40-261">Secondary replicas are given read status (can only read from existing Reliable Collections).</span></span> <span data-ttu-id="08e40-262">Most work in a stateful service is performed at the primary replica.</span><span class="sxs-lookup"><span data-stu-id="08e40-262">Most work in a stateful service is performed at the primary replica.</span></span> <span data-ttu-id="08e40-263">Secondary replicas can perform read-only validation, report generation, data mining, or other read-only jobs.</span><span class="sxs-lookup"><span data-stu-id="08e40-263">Secondary replicas can perform read-only validation, report generation, data mining, or other read-only jobs.</span></span>

## <a name="next-steps"></a><span data-ttu-id="08e40-264">Next steps</span><span class="sxs-lookup"><span data-stu-id="08e40-264">Next steps</span></span>
- [<span data-ttu-id="08e40-265">Introduction to Reliable Services</span><span class="sxs-lookup"><span data-stu-id="08e40-265">Introduction to Reliable Services</span></span>](service-fabric-reliable-services-introduction.md)
- [<span data-ttu-id="08e40-266">Reliable Services quick start</span><span class="sxs-lookup"><span data-stu-id="08e40-266">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
- [<span data-ttu-id="08e40-267">Replicas and instances</span><span class="sxs-lookup"><span data-stu-id="08e40-267">Replicas and instances</span></span>](service-fabric-concepts-replica-lifecycle.md)
