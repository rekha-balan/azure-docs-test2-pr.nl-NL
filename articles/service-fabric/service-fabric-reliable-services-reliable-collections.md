---
title: Save application state in Azure microservices| Microsoft Docs
description: Service Fabric stateful services provide reliable collections that enable you to write highly available, scalable, and low-latency cloud applications.
services: service-fabric
documentationcenter: .net
author: mcoskun
manager: timlt
editor: masnider,vturecek
ms.assetid: 62857523-604b-434e-bd1c-2141ea4b00d1
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: required
ms.date: 3/27/2017
ms.author: mcoskun
ms.openlocfilehash: 3af0af248bddc5d682618bef1a3250b0651aa50f
ms.sourcegitcommit: 5b9d839c0c0a94b293fdafe1d6e5429506c07e05
ms.translationtype: HT
ms.contentlocale: nl-NL
ms.lasthandoff: 08/02/2018
ms.locfileid: "44540662"
---
# <a name="introduction-to-reliable-collections-in-azure-service-fabric-stateful-services"></a><span data-ttu-id="b43b6-103">Introduction to Reliable Collections in Azure Service Fabric stateful services</span><span class="sxs-lookup"><span data-stu-id="b43b6-103">Introduction to Reliable Collections in Azure Service Fabric stateful services</span></span>
<span data-ttu-id="b43b6-104">Reliable Collections enable you to write highly available, scalable, and low-latency cloud applications as though you were writing single computer applications.</span><span class="sxs-lookup"><span data-stu-id="b43b6-104">Reliable Collections enable you to write highly available, scalable, and low-latency cloud applications as though you were writing single computer applications.</span></span> <span data-ttu-id="b43b6-105">The classes in the **Microsoft.ServiceFabric.Data.Collections** namespace provide a set of out-of-the-box collections that automatically make your state highly available.</span><span class="sxs-lookup"><span data-stu-id="b43b6-105">The classes in the **Microsoft.ServiceFabric.Data.Collections** namespace provide a set of out-of-the-box collections that automatically make your state highly available.</span></span> <span data-ttu-id="b43b6-106">Developers need to program only to the Reliable Collection APIs and let Reliable Collections manage the replicated and local state.</span><span class="sxs-lookup"><span data-stu-id="b43b6-106">Developers need to program only to the Reliable Collection APIs and let Reliable Collections manage the replicated and local state.</span></span>

<span data-ttu-id="b43b6-107">The key difference between Reliable Collections and other high-availability technologies (such as Redis, Azure Table service, and Azure Queue service) is that the state is kept locally in the service instance while also being made highly available.</span><span class="sxs-lookup"><span data-stu-id="b43b6-107">The key difference between Reliable Collections and other high-availability technologies (such as Redis, Azure Table service, and Azure Queue service) is that the state is kept locally in the service instance while also being made highly available.</span></span> <span data-ttu-id="b43b6-108">This means that:</span><span class="sxs-lookup"><span data-stu-id="b43b6-108">This means that:</span></span>

* <span data-ttu-id="b43b6-109">All reads are local, which results in low latency and high-throughput reads.</span><span class="sxs-lookup"><span data-stu-id="b43b6-109">All reads are local, which results in low latency and high-throughput reads.</span></span>
* <span data-ttu-id="b43b6-110">All writes incur the minimum number of network IOs, which results in low latency and high-throughput writes.</span><span class="sxs-lookup"><span data-stu-id="b43b6-110">All writes incur the minimum number of network IOs, which results in low latency and high-throughput writes.</span></span>

![Image of evolution of collections.](https://docstestmedia1.blob.core.windows.net/azure-media/articles/service-fabric/media/service-fabric-reliable-services-reliable-collections/ReliableCollectionsEvolution.png)

<span data-ttu-id="b43b6-112">Reliable Collections can be thought of as the natural evolution of the **System.Collections** classes: a new set of collections that are designed for the cloud and multi-computer applications without increasing complexity for the developer.</span><span class="sxs-lookup"><span data-stu-id="b43b6-112">Reliable Collections can be thought of as the natural evolution of the **System.Collections** classes: a new set of collections that are designed for the cloud and multi-computer applications without increasing complexity for the developer.</span></span> <span data-ttu-id="b43b6-113">As such, Reliable Collections are:</span><span class="sxs-lookup"><span data-stu-id="b43b6-113">As such, Reliable Collections are:</span></span>

* <span data-ttu-id="b43b6-114">Replicated: State changes are replicated for high availability.</span><span class="sxs-lookup"><span data-stu-id="b43b6-114">Replicated: State changes are replicated for high availability.</span></span>
* <span data-ttu-id="b43b6-115">Persisted: Data is persisted to disk for durability against large-scale outages (for example, a datacenter power outage).</span><span class="sxs-lookup"><span data-stu-id="b43b6-115">Persisted: Data is persisted to disk for durability against large-scale outages (for example, a datacenter power outage).</span></span>
* <span data-ttu-id="b43b6-116">Asynchronous: APIs are asynchronous to ensure that threads are not blocked when incurring IO.</span><span class="sxs-lookup"><span data-stu-id="b43b6-116">Asynchronous: APIs are asynchronous to ensure that threads are not blocked when incurring IO.</span></span>
* <span data-ttu-id="b43b6-117">Transactional: APIs utilize the abstraction of transactions so you can manage multiple Reliable Collections within a service easily.</span><span class="sxs-lookup"><span data-stu-id="b43b6-117">Transactional: APIs utilize the abstraction of transactions so you can manage multiple Reliable Collections within a service easily.</span></span>

<span data-ttu-id="b43b6-118">Reliable Collections provide strong consistency guarantees out of the box in order to make reasoning about application state easier.</span><span class="sxs-lookup"><span data-stu-id="b43b6-118">Reliable Collections provide strong consistency guarantees out of the box in order to make reasoning about application state easier.</span></span>
<span data-ttu-id="b43b6-119">Strong consistency is achieved by ensuring transaction commits finish only after the entire transaction has been logged on a majority quorum of replicas, including the primary.</span><span class="sxs-lookup"><span data-stu-id="b43b6-119">Strong consistency is achieved by ensuring transaction commits finish only after the entire transaction has been logged on a majority quorum of replicas, including the primary.</span></span>
<span data-ttu-id="b43b6-120">To achieve weaker consistency, applications can acknowledge back to the client/requester before the asynchronous commit returns.</span><span class="sxs-lookup"><span data-stu-id="b43b6-120">To achieve weaker consistency, applications can acknowledge back to the client/requester before the asynchronous commit returns.</span></span>

<span data-ttu-id="b43b6-121">The Reliable Collections APIs are an evolution of concurrent collections APIs (found in the **System.Collections.Concurrent** namespace):</span><span class="sxs-lookup"><span data-stu-id="b43b6-121">The Reliable Collections APIs are an evolution of concurrent collections APIs (found in the **System.Collections.Concurrent** namespace):</span></span>

* <span data-ttu-id="b43b6-122">Asynchronous: Returns a task since, unlike concurrent collections, the operations are replicated and persisted.</span><span class="sxs-lookup"><span data-stu-id="b43b6-122">Asynchronous: Returns a task since, unlike concurrent collections, the operations are replicated and persisted.</span></span>
* <span data-ttu-id="b43b6-123">No out parameters: Uses `ConditionalValue<T>` to return a bool and a value instead of out parameters.</span><span class="sxs-lookup"><span data-stu-id="b43b6-123">No out parameters: Uses `ConditionalValue<T>` to return a bool and a value instead of out parameters.</span></span> <span data-ttu-id="b43b6-124">`ConditionalValue<T>` is like `Nullable<T>` but does not require T to be a struct.</span><span class="sxs-lookup"><span data-stu-id="b43b6-124">`ConditionalValue<T>` is like `Nullable<T>` but does not require T to be a struct.</span></span>
* <span data-ttu-id="b43b6-125">Transactions: Uses a transaction object to enable the user to group actions on multiple Reliable Collections in a transaction.</span><span class="sxs-lookup"><span data-stu-id="b43b6-125">Transactions: Uses a transaction object to enable the user to group actions on multiple Reliable Collections in a transaction.</span></span>

<span data-ttu-id="b43b6-126">Today, **Microsoft.ServiceFabric.Data.Collections** contains two collections:</span><span class="sxs-lookup"><span data-stu-id="b43b6-126">Today, **Microsoft.ServiceFabric.Data.Collections** contains two collections:</span></span>

* <span data-ttu-id="b43b6-127">[Reliable Dictionary](https://msdn.microsoft.com/library/azure/dn971511.aspx): Represents a replicated, transactional, and asynchronous collection of key/value pairs.</span><span class="sxs-lookup"><span data-stu-id="b43b6-127">[Reliable Dictionary](https://msdn.microsoft.com/library/azure/dn971511.aspx): Represents a replicated, transactional, and asynchronous collection of key/value pairs.</span></span> <span data-ttu-id="b43b6-128">Similar to **ConcurrentDictionary**, both the key and the value can be of any type.</span><span class="sxs-lookup"><span data-stu-id="b43b6-128">Similar to **ConcurrentDictionary**, both the key and the value can be of any type.</span></span>
* <span data-ttu-id="b43b6-129">[Reliable Queue](https://msdn.microsoft.com/library/azure/dn971527.aspx): Represents a replicated, transactional, and asynchronous strict first-in, first-out (FIFO) queue.</span><span class="sxs-lookup"><span data-stu-id="b43b6-129">[Reliable Queue](https://msdn.microsoft.com/library/azure/dn971527.aspx): Represents a replicated, transactional, and asynchronous strict first-in, first-out (FIFO) queue.</span></span> <span data-ttu-id="b43b6-130">Similar to **ConcurrentQueue**, the value can be of any type.</span><span class="sxs-lookup"><span data-stu-id="b43b6-130">Similar to **ConcurrentQueue**, the value can be of any type.</span></span>

## <a name="isolation-levels"></a><span data-ttu-id="b43b6-131">Isolation levels</span><span class="sxs-lookup"><span data-stu-id="b43b6-131">Isolation levels</span></span>
<span data-ttu-id="b43b6-132">Isolation level defines the degree to which the transaction must be isolated from modifications made by other transactions.</span><span class="sxs-lookup"><span data-stu-id="b43b6-132">Isolation level defines the degree to which the transaction must be isolated from modifications made by other transactions.</span></span>
<span data-ttu-id="b43b6-133">There are two isolation levels that are supported in Reliable Collections:</span><span class="sxs-lookup"><span data-stu-id="b43b6-133">There are two isolation levels that are supported in Reliable Collections:</span></span>

* <span data-ttu-id="b43b6-134">**Repeatable Read**: Specifies that statements cannot read data that has been modified but not yet committed by other transactions and that no other transactions can modify data that has been read by the current transaction until the current transaction finishes.</span><span class="sxs-lookup"><span data-stu-id="b43b6-134">**Repeatable Read**: Specifies that statements cannot read data that has been modified but not yet committed by other transactions and that no other transactions can modify data that has been read by the current transaction until the current transaction finishes.</span></span> <span data-ttu-id="b43b6-135">For more details, see [https://msdn.microsoft.com/library/ms173763.aspx](https://msdn.microsoft.com/library/ms173763.aspx).</span><span class="sxs-lookup"><span data-stu-id="b43b6-135">For more details, see [https://msdn.microsoft.com/library/ms173763.aspx](https://msdn.microsoft.com/library/ms173763.aspx).</span></span>
* <span data-ttu-id="b43b6-136">**Snapshot**: Specifies that data read by any statement in a transaction will be the transactionally consistent version of the data that existed at the start of the transaction.</span><span class="sxs-lookup"><span data-stu-id="b43b6-136">**Snapshot**: Specifies that data read by any statement in a transaction will be the transactionally consistent version of the data that existed at the start of the transaction.</span></span>
  <span data-ttu-id="b43b6-137">The transaction can recognize only data modifications that were committed before the start of the transaction.</span><span class="sxs-lookup"><span data-stu-id="b43b6-137">The transaction can recognize only data modifications that were committed before the start of the transaction.</span></span>
  <span data-ttu-id="b43b6-138">Data modifications made by other transactions after the start of the current transaction are not visible to statements executing in the current transaction.</span><span class="sxs-lookup"><span data-stu-id="b43b6-138">Data modifications made by other transactions after the start of the current transaction are not visible to statements executing in the current transaction.</span></span>
  <span data-ttu-id="b43b6-139">The effect is as if the statements in a transaction get a snapshot of the committed data as it existed at the start of the transaction.</span><span class="sxs-lookup"><span data-stu-id="b43b6-139">The effect is as if the statements in a transaction get a snapshot of the committed data as it existed at the start of the transaction.</span></span>
  <span data-ttu-id="b43b6-140">Snapshots are consistent across Reliable Collections.</span><span class="sxs-lookup"><span data-stu-id="b43b6-140">Snapshots are consistent across Reliable Collections.</span></span>
  <span data-ttu-id="b43b6-141">For more details, see [https://msdn.microsoft.com/library/ms173763.aspx](https://msdn.microsoft.com/library/ms173763.aspx).</span><span class="sxs-lookup"><span data-stu-id="b43b6-141">For more details, see [https://msdn.microsoft.com/library/ms173763.aspx](https://msdn.microsoft.com/library/ms173763.aspx).</span></span>

<span data-ttu-id="b43b6-142">Reliable Collections automatically choose the isolation level to use for a given read operation depending on the operation and the role of the replica at the time of transaction's creation.</span><span class="sxs-lookup"><span data-stu-id="b43b6-142">Reliable Collections automatically choose the isolation level to use for a given read operation depending on the operation and the role of the replica at the time of transaction's creation.</span></span>
<span data-ttu-id="b43b6-143">Following is the table that depicts isolation level defaults for Reliable Dictionary and Queue operations.</span><span class="sxs-lookup"><span data-stu-id="b43b6-143">Following is the table that depicts isolation level defaults for Reliable Dictionary and Queue operations.</span></span>

| <span data-ttu-id="b43b6-144">Operation \ Role</span><span class="sxs-lookup"><span data-stu-id="b43b6-144">Operation \ Role</span></span> | <span data-ttu-id="b43b6-145">Primary</span><span class="sxs-lookup"><span data-stu-id="b43b6-145">Primary</span></span> | <span data-ttu-id="b43b6-146">Secondary</span><span class="sxs-lookup"><span data-stu-id="b43b6-146">Secondary</span></span> |
| --- |:--- |:--- |
| <span data-ttu-id="b43b6-147">Single Entity Read</span><span class="sxs-lookup"><span data-stu-id="b43b6-147">Single Entity Read</span></span> |<span data-ttu-id="b43b6-148">Repeatable Read</span><span class="sxs-lookup"><span data-stu-id="b43b6-148">Repeatable Read</span></span> |<span data-ttu-id="b43b6-149">Snapshot</span><span class="sxs-lookup"><span data-stu-id="b43b6-149">Snapshot</span></span> |
| <span data-ttu-id="b43b6-150">Enumeration \ Count</span><span class="sxs-lookup"><span data-stu-id="b43b6-150">Enumeration \ Count</span></span> |<span data-ttu-id="b43b6-151">Snapshot</span><span class="sxs-lookup"><span data-stu-id="b43b6-151">Snapshot</span></span> |<span data-ttu-id="b43b6-152">Snapshot</span><span class="sxs-lookup"><span data-stu-id="b43b6-152">Snapshot</span></span> |

> [!NOTE]
> <span data-ttu-id="b43b6-153">Common examples for Single Entity Operations are `IReliableDictionary.TryGetValueAsync`, `IReliableQueue.TryPeekAsync`.</span><span class="sxs-lookup"><span data-stu-id="b43b6-153">Common examples for Single Entity Operations are `IReliableDictionary.TryGetValueAsync`, `IReliableQueue.TryPeekAsync`.</span></span>
> 
> 

<span data-ttu-id="b43b6-154">Both the Reliable Dictionary and the Reliable Queue support Read Your Writes.</span><span class="sxs-lookup"><span data-stu-id="b43b6-154">Both the Reliable Dictionary and the Reliable Queue support Read Your Writes.</span></span>
<span data-ttu-id="b43b6-155">In other words, any write within a transaction will be visible to a following read that belongs to the same transaction.</span><span class="sxs-lookup"><span data-stu-id="b43b6-155">In other words, any write within a transaction will be visible to a following read that belongs to the same transaction.</span></span>

## <a name="locking"></a><span data-ttu-id="b43b6-156">Locking</span><span class="sxs-lookup"><span data-stu-id="b43b6-156">Locking</span></span>
<span data-ttu-id="b43b6-157">In Reliable Collections, all transactions are two-phased: a transaction does not release the locks it has acquired until the transaction terminates with either an abort or a commit.</span><span class="sxs-lookup"><span data-stu-id="b43b6-157">In Reliable Collections, all transactions are two-phased: a transaction does not release the locks it has acquired until the transaction terminates with either an abort or a commit.</span></span>

<span data-ttu-id="b43b6-158">Reliable Dictionary uses row level locking for all single entity operations.</span><span class="sxs-lookup"><span data-stu-id="b43b6-158">Reliable Dictionary uses row level locking for all single entity operations.</span></span>
<span data-ttu-id="b43b6-159">Reliable Queue trades off concurrency for strict transactional FIFO property.</span><span class="sxs-lookup"><span data-stu-id="b43b6-159">Reliable Queue trades off concurrency for strict transactional FIFO property.</span></span>
<span data-ttu-id="b43b6-160">Reliable Queue uses operation level locks allowing one transaction with `TryPeekAsync` and/or `TryDequeueAsync` and one transaction with `EnqueueAsync` at a time.</span><span class="sxs-lookup"><span data-stu-id="b43b6-160">Reliable Queue uses operation level locks allowing one transaction with `TryPeekAsync` and/or `TryDequeueAsync` and one transaction with `EnqueueAsync` at a time.</span></span>
<span data-ttu-id="b43b6-161">Note that to preserve FIFO, if a `TryPeekAsync` or `TryDequeueAsync` ever observes that the Reliable Queue is empty, they will also lock `EnqueueAsync`.</span><span class="sxs-lookup"><span data-stu-id="b43b6-161">Note that to preserve FIFO, if a `TryPeekAsync` or `TryDequeueAsync` ever observes that the Reliable Queue is empty, they will also lock `EnqueueAsync`.</span></span>

<span data-ttu-id="b43b6-162">Write operations always take Exclusive locks.</span><span class="sxs-lookup"><span data-stu-id="b43b6-162">Write operations always take Exclusive locks.</span></span>
<span data-ttu-id="b43b6-163">For read operations, the locking depends on a couple of factors.</span><span class="sxs-lookup"><span data-stu-id="b43b6-163">For read operations, the locking depends on a couple of factors.</span></span>
<span data-ttu-id="b43b6-164">Any read operation done using Snapshot isolation is lock free.</span><span class="sxs-lookup"><span data-stu-id="b43b6-164">Any read operation done using Snapshot isolation is lock free.</span></span>
<span data-ttu-id="b43b6-165">Any Repeatable Read operation by default takes Shared locks.</span><span class="sxs-lookup"><span data-stu-id="b43b6-165">Any Repeatable Read operation by default takes Shared locks.</span></span>
<span data-ttu-id="b43b6-166">However, for any read operation that supports Repeatable Read, the user can ask for an Update lock instead of the Shared lock.</span><span class="sxs-lookup"><span data-stu-id="b43b6-166">However, for any read operation that supports Repeatable Read, the user can ask for an Update lock instead of the Shared lock.</span></span>
<span data-ttu-id="b43b6-167">An Update lock is an asymmetric lock used to prevent a common form of deadlock that occurs when multiple transactions lock resources for potential updates at a later time.</span><span class="sxs-lookup"><span data-stu-id="b43b6-167">An Update lock is an asymmetric lock used to prevent a common form of deadlock that occurs when multiple transactions lock resources for potential updates at a later time.</span></span>

<span data-ttu-id="b43b6-168">The lock compatibility matrix can be found below:</span><span class="sxs-lookup"><span data-stu-id="b43b6-168">The lock compatibility matrix can be found below:</span></span>

| <span data-ttu-id="b43b6-169">Request \ Granted</span><span class="sxs-lookup"><span data-stu-id="b43b6-169">Request \ Granted</span></span> | <span data-ttu-id="b43b6-170">None</span><span class="sxs-lookup"><span data-stu-id="b43b6-170">None</span></span> | <span data-ttu-id="b43b6-171">Shared</span><span class="sxs-lookup"><span data-stu-id="b43b6-171">Shared</span></span> | <span data-ttu-id="b43b6-172">Update</span><span class="sxs-lookup"><span data-stu-id="b43b6-172">Update</span></span> | <span data-ttu-id="b43b6-173">Exclusive</span><span class="sxs-lookup"><span data-stu-id="b43b6-173">Exclusive</span></span> |
| --- |:--- |:--- |:--- |:--- |
| <span data-ttu-id="b43b6-174">Shared</span><span class="sxs-lookup"><span data-stu-id="b43b6-174">Shared</span></span> |<span data-ttu-id="b43b6-175">No conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-175">No conflict</span></span> |<span data-ttu-id="b43b6-176">No conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-176">No conflict</span></span> |<span data-ttu-id="b43b6-177">Conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-177">Conflict</span></span> |<span data-ttu-id="b43b6-178">Conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-178">Conflict</span></span> |
| <span data-ttu-id="b43b6-179">Update</span><span class="sxs-lookup"><span data-stu-id="b43b6-179">Update</span></span> |<span data-ttu-id="b43b6-180">No conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-180">No conflict</span></span> |<span data-ttu-id="b43b6-181">No conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-181">No conflict</span></span> |<span data-ttu-id="b43b6-182">Conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-182">Conflict</span></span> |<span data-ttu-id="b43b6-183">Conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-183">Conflict</span></span> |
| <span data-ttu-id="b43b6-184">Exclusive</span><span class="sxs-lookup"><span data-stu-id="b43b6-184">Exclusive</span></span> |<span data-ttu-id="b43b6-185">No conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-185">No conflict</span></span> |<span data-ttu-id="b43b6-186">Conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-186">Conflict</span></span> |<span data-ttu-id="b43b6-187">Conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-187">Conflict</span></span> |<span data-ttu-id="b43b6-188">Conflict</span><span class="sxs-lookup"><span data-stu-id="b43b6-188">Conflict</span></span> |

<span data-ttu-id="b43b6-189">Note that a time-out argument in the Reliable Collections APIs is used for deadlock detection.</span><span class="sxs-lookup"><span data-stu-id="b43b6-189">Note that a time-out argument in the Reliable Collections APIs is used for deadlock detection.</span></span>
<span data-ttu-id="b43b6-190">For example, two transactions (T1 and T2) are trying to read and update K1.</span><span class="sxs-lookup"><span data-stu-id="b43b6-190">For example, two transactions (T1 and T2) are trying to read and update K1.</span></span>
<span data-ttu-id="b43b6-191">It is possible for them to deadlock, because they both end up having the Shared lock.</span><span class="sxs-lookup"><span data-stu-id="b43b6-191">It is possible for them to deadlock, because they both end up having the Shared lock.</span></span>
<span data-ttu-id="b43b6-192">In this case, one or both of the operations will time out.</span><span class="sxs-lookup"><span data-stu-id="b43b6-192">In this case, one or both of the operations will time out.</span></span>

<span data-ttu-id="b43b6-193">Note that the above deadlock scenario is a great example of how an Update lock can prevent deadlocks.</span><span class="sxs-lookup"><span data-stu-id="b43b6-193">Note that the above deadlock scenario is a great example of how an Update lock can prevent deadlocks.</span></span>

## <a name="persistence-model"></a><span data-ttu-id="b43b6-194">Persistence model</span><span class="sxs-lookup"><span data-stu-id="b43b6-194">Persistence model</span></span>
<span data-ttu-id="b43b6-195">The Reliable State Manager and Reliable Collections follow a persistence model that is called Log and Checkpoint.</span><span class="sxs-lookup"><span data-stu-id="b43b6-195">The Reliable State Manager and Reliable Collections follow a persistence model that is called Log and Checkpoint.</span></span>
<span data-ttu-id="b43b6-196">This is a model where each state change is logged on disk and applied only in memory.</span><span class="sxs-lookup"><span data-stu-id="b43b6-196">This is a model where each state change is logged on disk and applied only in memory.</span></span>
<span data-ttu-id="b43b6-197">The complete state itself is persisted only occasionally (a.k.a.</span><span class="sxs-lookup"><span data-stu-id="b43b6-197">The complete state itself is persisted only occasionally (a.k.a.</span></span> <span data-ttu-id="b43b6-198">Checkpoint).</span><span class="sxs-lookup"><span data-stu-id="b43b6-198">Checkpoint).</span></span>
<span data-ttu-id="b43b6-199">The benefit is that deltas are turned into sequential append-only writes on disk for improved performance.</span><span class="sxs-lookup"><span data-stu-id="b43b6-199">The benefit is that deltas are turned into sequential append-only writes on disk for improved performance.</span></span>

<span data-ttu-id="b43b6-200">To better understand the Log and Checkpoint model, let’s first look at the infinite disk scenario.</span><span class="sxs-lookup"><span data-stu-id="b43b6-200">To better understand the Log and Checkpoint model, let’s first look at the infinite disk scenario.</span></span>
<span data-ttu-id="b43b6-201">The Reliable State Manager logs every operation before it is replicated.</span><span class="sxs-lookup"><span data-stu-id="b43b6-201">The Reliable State Manager logs every operation before it is replicated.</span></span>
<span data-ttu-id="b43b6-202">This allows the Reliable Collection to apply only the operation in memory.</span><span class="sxs-lookup"><span data-stu-id="b43b6-202">This allows the Reliable Collection to apply only the operation in memory.</span></span>
<span data-ttu-id="b43b6-203">Since logs are persisted, even when the replica fails and needs to be restarted, the Reliable State Manager has enough information in its logs to replay all the operations the replica has lost.</span><span class="sxs-lookup"><span data-stu-id="b43b6-203">Since logs are persisted, even when the replica fails and needs to be restarted, the Reliable State Manager has enough information in its logs to replay all the operations the replica has lost.</span></span>
<span data-ttu-id="b43b6-204">As the disk is infinite, log records never need to be removed and the Reliable Collection needs to manage only the in-memory state.</span><span class="sxs-lookup"><span data-stu-id="b43b6-204">As the disk is infinite, log records never need to be removed and the Reliable Collection needs to manage only the in-memory state.</span></span>

<span data-ttu-id="b43b6-205">Now let’s look at the finite disk scenario.</span><span class="sxs-lookup"><span data-stu-id="b43b6-205">Now let’s look at the finite disk scenario.</span></span>
<span data-ttu-id="b43b6-206">As log records accumulate, the Reliable State Manager will run out of disk space.</span><span class="sxs-lookup"><span data-stu-id="b43b6-206">As log records accumulate, the Reliable State Manager will run out of disk space.</span></span>
<span data-ttu-id="b43b6-207">Before that happens, the Reliable State Manager needs to truncate its log to make room for the newer records.</span><span class="sxs-lookup"><span data-stu-id="b43b6-207">Before that happens, the Reliable State Manager needs to truncate its log to make room for the newer records.</span></span>
<span data-ttu-id="b43b6-208">It will request the Reliable Collections to checkpoint their in-memory state to disk.</span><span class="sxs-lookup"><span data-stu-id="b43b6-208">It will request the Reliable Collections to checkpoint their in-memory state to disk.</span></span>
<span data-ttu-id="b43b6-209">It is the Reliable Collections' responsibility to persist its state up to that point.</span><span class="sxs-lookup"><span data-stu-id="b43b6-209">It is the Reliable Collections' responsibility to persist its state up to that point.</span></span>
<span data-ttu-id="b43b6-210">Once the Reliable Collections complete their checkpoints, the Reliable State Manager can truncate the log to free up disk space.</span><span class="sxs-lookup"><span data-stu-id="b43b6-210">Once the Reliable Collections complete their checkpoints, the Reliable State Manager can truncate the log to free up disk space.</span></span>
<span data-ttu-id="b43b6-211">This way, when the replica needs to be restarted, Reliable Collections will recover their checkpointed state, and the Reliable State Manager will recover and play back all the state changes that occurred since the checkpoint.</span><span class="sxs-lookup"><span data-stu-id="b43b6-211">This way, when the replica needs to be restarted, Reliable Collections will recover their checkpointed state, and the Reliable State Manager will recover and play back all the state changes that occurred since the checkpoint.</span></span>

> [!NOTE]
> <span data-ttu-id="b43b6-212">Another value add of checkpointing is that it improves recovery performance in common cases.</span><span class="sxs-lookup"><span data-stu-id="b43b6-212">Another value add of checkpointing is that it improves recovery performance in common cases.</span></span>
> <span data-ttu-id="b43b6-213">This is because checkpoints contain only the latest versions.</span><span class="sxs-lookup"><span data-stu-id="b43b6-213">This is because checkpoints contain only the latest versions.</span></span>
> 
> 

## <a name="recommendations"></a><span data-ttu-id="b43b6-214">Recommendations</span><span class="sxs-lookup"><span data-stu-id="b43b6-214">Recommendations</span></span>
* <span data-ttu-id="b43b6-215">Do not modify an object of custom type returned by read operations (e.g., `TryPeekAsync` or `TryGetValueAsync`).</span><span class="sxs-lookup"><span data-stu-id="b43b6-215">Do not modify an object of custom type returned by read operations (e.g., `TryPeekAsync` or `TryGetValueAsync`).</span></span> <span data-ttu-id="b43b6-216">Reliable Collections, just like Concurrent Collections, return a reference to the objects and not a copy.</span><span class="sxs-lookup"><span data-stu-id="b43b6-216">Reliable Collections, just like Concurrent Collections, return a reference to the objects and not a copy.</span></span>
* <span data-ttu-id="b43b6-217">Do deep copy the returned object of a custom type before modifying it.</span><span class="sxs-lookup"><span data-stu-id="b43b6-217">Do deep copy the returned object of a custom type before modifying it.</span></span> <span data-ttu-id="b43b6-218">Since structs and built-in types are pass-by-value, you do not need to do a deep copy on them.</span><span class="sxs-lookup"><span data-stu-id="b43b6-218">Since structs and built-in types are pass-by-value, you do not need to do a deep copy on them.</span></span>
* <span data-ttu-id="b43b6-219">Do not use `TimeSpan.MaxValue` for time-outs.</span><span class="sxs-lookup"><span data-stu-id="b43b6-219">Do not use `TimeSpan.MaxValue` for time-outs.</span></span> <span data-ttu-id="b43b6-220">Time-outs should be used to detect deadlocks.</span><span class="sxs-lookup"><span data-stu-id="b43b6-220">Time-outs should be used to detect deadlocks.</span></span>
* <span data-ttu-id="b43b6-221">Do not use a transaction after it has been committed, aborted, or disposed.</span><span class="sxs-lookup"><span data-stu-id="b43b6-221">Do not use a transaction after it has been committed, aborted, or disposed.</span></span>
* <span data-ttu-id="b43b6-222">Do not use an enumeration outside of the transaction scope it was created in.</span><span class="sxs-lookup"><span data-stu-id="b43b6-222">Do not use an enumeration outside of the transaction scope it was created in.</span></span>
* <span data-ttu-id="b43b6-223">Do not create a transaction within another transaction’s `using` statement because it can cause deadlocks.</span><span class="sxs-lookup"><span data-stu-id="b43b6-223">Do not create a transaction within another transaction’s `using` statement because it can cause deadlocks.</span></span>
* <span data-ttu-id="b43b6-224">Do ensure that your `IComparable<TKey>` implementation is correct.</span><span class="sxs-lookup"><span data-stu-id="b43b6-224">Do ensure that your `IComparable<TKey>` implementation is correct.</span></span> <span data-ttu-id="b43b6-225">The system takes dependency on this for merging checkpoints.</span><span class="sxs-lookup"><span data-stu-id="b43b6-225">The system takes dependency on this for merging checkpoints.</span></span>
* <span data-ttu-id="b43b6-226">Do use Update lock when reading an item with an intention to update it to prevent a certain class of deadlocks.</span><span class="sxs-lookup"><span data-stu-id="b43b6-226">Do use Update lock when reading an item with an intention to update it to prevent a certain class of deadlocks.</span></span>
* <span data-ttu-id="b43b6-227">Consider keeping your items (e.g. TKey + TValue for Reliable Dictionary) below 80 KBytes: smaller the better.</span><span class="sxs-lookup"><span data-stu-id="b43b6-227">Consider keeping your items (e.g. TKey + TValue for Reliable Dictionary) below 80 KBytes: smaller the better.</span></span> <span data-ttu-id="b43b6-228">This will reduce the amount of Large Object Heap usage as well as disk and network IO requirements.</span><span class="sxs-lookup"><span data-stu-id="b43b6-228">This will reduce the amount of Large Object Heap usage as well as disk and network IO requirements.</span></span> <span data-ttu-id="b43b6-229">In many cases, it will also reduce replicating duplicate data when only one small part of the value is being updated.</span><span class="sxs-lookup"><span data-stu-id="b43b6-229">In many cases, it will also reduce replicating duplicate data when only one small part of the value is being updated.</span></span> <span data-ttu-id="b43b6-230">Common way to achieve this in Reliable Dictionary, is to break your rows in to multiple rows.</span><span class="sxs-lookup"><span data-stu-id="b43b6-230">Common way to achieve this in Reliable Dictionary, is to break your rows in to multiple rows.</span></span> 
* <span data-ttu-id="b43b6-231">Consider using backup and restore functionality to have disaster recovery.</span><span class="sxs-lookup"><span data-stu-id="b43b6-231">Consider using backup and restore functionality to have disaster recovery.</span></span>
* <span data-ttu-id="b43b6-232">Avoid mixing single entity operations and multi-entity operations (e.g `GetCountAsync`, `CreateEnumerableAsync`) in the same transaction due to the different isolation levels.</span><span class="sxs-lookup"><span data-stu-id="b43b6-232">Avoid mixing single entity operations and multi-entity operations (e.g `GetCountAsync`, `CreateEnumerableAsync`) in the same transaction due to the different isolation levels.</span></span>
* <span data-ttu-id="b43b6-233">Do handle InvalidOperationException.</span><span class="sxs-lookup"><span data-stu-id="b43b6-233">Do handle InvalidOperationException.</span></span> <span data-ttu-id="b43b6-234">User transactions can be aborted by the system for variety of reasons.</span><span class="sxs-lookup"><span data-stu-id="b43b6-234">User transactions can be aborted by the system for variety of reasons.</span></span> <span data-ttu-id="b43b6-235">For example, when the Reliable State Manager is changing its role out of Primary or when a long-running transaction is blocking truncation of the transactional log.</span><span class="sxs-lookup"><span data-stu-id="b43b6-235">For example, when the Reliable State Manager is changing its role out of Primary or when a long-running transaction is blocking truncation of the transactional log.</span></span> <span data-ttu-id="b43b6-236">In such cases, user may receve InvalidOperationException indicating that their transaction has already been terminated.</span><span class="sxs-lookup"><span data-stu-id="b43b6-236">In such cases, user may receve InvalidOperationException indicating that their transaction has already been terminated.</span></span> <span data-ttu-id="b43b6-237">Assuming, the termination of the transaction was not requested by the user, best way to handle this exception is to dispose the transaction, check if the cancellation token has been signaled (or the role of the replica has been changed), and if not create a new transaction and retry.</span><span class="sxs-lookup"><span data-stu-id="b43b6-237">Assuming, the termination of the transaction was not requested by the user, best way to handle this exception is to dispose the transaction, check if the cancellation token has been signaled (or the role of the replica has been changed), and if not create a new transaction and retry.</span></span>  

<span data-ttu-id="b43b6-238">Here are some things to keep in mind:</span><span class="sxs-lookup"><span data-stu-id="b43b6-238">Here are some things to keep in mind:</span></span>

* <span data-ttu-id="b43b6-239">The default time-out is 4 seconds for all the Reliable Collection APIs.</span><span class="sxs-lookup"><span data-stu-id="b43b6-239">The default time-out is 4 seconds for all the Reliable Collection APIs.</span></span> <span data-ttu-id="b43b6-240">Most users should not override this.</span><span class="sxs-lookup"><span data-stu-id="b43b6-240">Most users should not override this.</span></span>
* <span data-ttu-id="b43b6-241">The default cancellation token is `CancellationToken.None` in all Reliable Collections APIs.</span><span class="sxs-lookup"><span data-stu-id="b43b6-241">The default cancellation token is `CancellationToken.None` in all Reliable Collections APIs.</span></span>
* <span data-ttu-id="b43b6-242">The key type parameter (*TKey*) for a Reliable Dictionary must correctly implement `GetHashCode()` and `Equals()`.</span><span class="sxs-lookup"><span data-stu-id="b43b6-242">The key type parameter (*TKey*) for a Reliable Dictionary must correctly implement `GetHashCode()` and `Equals()`.</span></span> <span data-ttu-id="b43b6-243">Keys must be immutable.</span><span class="sxs-lookup"><span data-stu-id="b43b6-243">Keys must be immutable.</span></span>
* <span data-ttu-id="b43b6-244">To achieve high availability for the Reliable Collections, each service should have at least a target and minimum replica set size of 3.</span><span class="sxs-lookup"><span data-stu-id="b43b6-244">To achieve high availability for the Reliable Collections, each service should have at least a target and minimum replica set size of 3.</span></span>
* <span data-ttu-id="b43b6-245">Read operations on the secondary may read versions that are not quorum committed.</span><span class="sxs-lookup"><span data-stu-id="b43b6-245">Read operations on the secondary may read versions that are not quorum committed.</span></span>
  <span data-ttu-id="b43b6-246">This means that a version of data that is read from a single secondary might be false progressed.</span><span class="sxs-lookup"><span data-stu-id="b43b6-246">This means that a version of data that is read from a single secondary might be false progressed.</span></span>
  <span data-ttu-id="b43b6-247">Of course, reads from Primary are always stable: can never be false progressed.</span><span class="sxs-lookup"><span data-stu-id="b43b6-247">Of course, reads from Primary are always stable: can never be false progressed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="b43b6-248">Next steps</span><span class="sxs-lookup"><span data-stu-id="b43b6-248">Next steps</span></span>
* [<span data-ttu-id="b43b6-249">Reliable Services quick start</span><span class="sxs-lookup"><span data-stu-id="b43b6-249">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="b43b6-250">Working with Reliable Collections</span><span class="sxs-lookup"><span data-stu-id="b43b6-250">Working with Reliable Collections</span></span>](service-fabric-work-with-reliable-collections.md)
* [<span data-ttu-id="b43b6-251">Reliable Services notifications</span><span class="sxs-lookup"><span data-stu-id="b43b6-251">Reliable Services notifications</span></span>](service-fabric-reliable-services-notifications.md)
* [<span data-ttu-id="b43b6-252">Reliable Services backup and restore (disaster recovery)</span><span class="sxs-lookup"><span data-stu-id="b43b6-252">Reliable Services backup and restore (disaster recovery)</span></span>](service-fabric-reliable-services-backup-restore.md)
* [<span data-ttu-id="b43b6-253">Reliable State Manager configuration</span><span class="sxs-lookup"><span data-stu-id="b43b6-253">Reliable State Manager configuration</span></span>](service-fabric-reliable-services-configuration.md)
* [<span data-ttu-id="b43b6-254">Getting started with Service Fabric Web API services</span><span class="sxs-lookup"><span data-stu-id="b43b6-254">Getting started with Service Fabric Web API services</span></span>](service-fabric-reliable-services-communication-webapi.md)
* [<span data-ttu-id="b43b6-255">Advanced usage of the Reliable Services programming model</span><span class="sxs-lookup"><span data-stu-id="b43b6-255">Advanced usage of the Reliable Services programming model</span></span>](service-fabric-reliable-services-advanced-usage.md)
* [<span data-ttu-id="b43b6-256">Developer reference for Reliable Collections</span><span class="sxs-lookup"><span data-stu-id="b43b6-256">Developer reference for Reliable Collections</span></span>](https://msdn.microsoft.com/library/azure/microsoft.servicefabric.data.collections.aspx)


