---
title: Partitioning and horizontal scaling in Azure Cosmos DB | Microsoft Docs
description: Learn about how partitioning works in Azure Cosmos DB, how to configure partitioning and partition keys, and how to pick the right partition key for your application.
services: cosmos-db
author: aliuy
manager: kfile
ms.service: cosmos-db
ms.devlang: na
ms.topic: conceptual
ms.date: 07/26/2018
ms.author: andrl
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: d53106efa4e3761a497e67181546c8ec09fd880c
ms.sourcegitcommit: d1451406a010fd3aa854dc8e5b77dc5537d8050e
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 09/13/2018
ms.locfileid: "44869044"
---
# <a name="partition-and-scale-in-azure-cosmos-db"></a><span data-ttu-id="c6158-103">Partition and scale in Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="c6158-103">Partition and scale in Azure Cosmos DB</span></span>

<span data-ttu-id="c6158-104">[Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) is a globally distributed, multi-model database service designed to help you achieve fast, predictable performance.</span><span class="sxs-lookup"><span data-stu-id="c6158-104">[Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) is a globally distributed, multi-model database service designed to help you achieve fast, predictable performance.</span></span> <span data-ttu-id="c6158-105">It scales seamlessly along with your application.</span><span class="sxs-lookup"><span data-stu-id="c6158-105">It scales seamlessly along with your application.</span></span> <span data-ttu-id="c6158-106">This article provides an overview of how partitioning works for all the data models in Azure Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="c6158-106">This article provides an overview of how partitioning works for all the data models in Azure Cosmos DB.</span></span> <span data-ttu-id="c6158-107">It also describes how to configure Azure Cosmos DB containers to effectively scale your applications.</span><span class="sxs-lookup"><span data-stu-id="c6158-107">It also describes how to configure Azure Cosmos DB containers to effectively scale your applications.</span></span>

<span data-ttu-id="c6158-108">Azure Cosmos DB supports the following types of containers across all APIs:</span><span class="sxs-lookup"><span data-stu-id="c6158-108">Azure Cosmos DB supports the following types of containers across all APIs:</span></span>

- <span data-ttu-id="c6158-109">**Fixed container**: These containers can store a graph database up to 10 GB in size with a maximum of 10,000 request units per second allocated to it.</span><span class="sxs-lookup"><span data-stu-id="c6158-109">**Fixed container**: These containers can store a graph database up to 10 GB in size with a maximum of 10,000 request units per second allocated to it.</span></span> <span data-ttu-id="c6158-110">To create a fixed container it isn't necessary to specify a partition key property in the data.</span><span class="sxs-lookup"><span data-stu-id="c6158-110">To create a fixed container it isn't necessary to specify a partition key property in the data.</span></span>

- <span data-ttu-id="c6158-111">**Unlimited container**: These containers can automatically scale to store a graph beyond the 10-GB limit through horizontal partitioning.</span><span class="sxs-lookup"><span data-stu-id="c6158-111">**Unlimited container**: These containers can automatically scale to store a graph beyond the 10-GB limit through horizontal partitioning.</span></span> <span data-ttu-id="c6158-112">Each partition will store 10 GB and the data will be automatically balanced based on the **specified partition key**, which will be a required parameter when using an unlimited container.</span><span class="sxs-lookup"><span data-stu-id="c6158-112">Each partition will store 10 GB and the data will be automatically balanced based on the **specified partition key**, which will be a required parameter when using an unlimited container.</span></span> <span data-ttu-id="c6158-113">This type of container can store a virtually unlimited data size and can allow up to 100,000 request units per second, or more [by contacting support](https://aka.ms/cosmosdbfeedback?subject=Cosmos%20DB%20More%20Throughput%20Request).</span><span class="sxs-lookup"><span data-stu-id="c6158-113">This type of container can store a virtually unlimited data size and can allow up to 100,000 request units per second, or more [by contacting support](https://aka.ms/cosmosdbfeedback?subject=Cosmos%20DB%20More%20Throughput%20Request).</span></span>

## <a name="partitioning-in-azure-cosmos-db"></a><span data-ttu-id="c6158-114">Partitioning in Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="c6158-114">Partitioning in Azure Cosmos DB</span></span>
<span data-ttu-id="c6158-115">Azure Cosmos DB provides containers for storing data called collections (for documents), graphs, or tables.</span><span class="sxs-lookup"><span data-stu-id="c6158-115">Azure Cosmos DB provides containers for storing data called collections (for documents), graphs, or tables.</span></span> <span data-ttu-id="c6158-116">Containers are logical resources and can span one or more physical partitions or servers.</span><span class="sxs-lookup"><span data-stu-id="c6158-116">Containers are logical resources and can span one or more physical partitions or servers.</span></span> <span data-ttu-id="c6158-117">The number of partitions is determined by Azure Cosmos DB based on the storage size and throughput provisioned for a container or a set of containers.</span><span class="sxs-lookup"><span data-stu-id="c6158-117">The number of partitions is determined by Azure Cosmos DB based on the storage size and throughput provisioned for a container or a set of containers.</span></span> 

### <a name="physical-partition"></a><span data-ttu-id="c6158-118">Physical partition</span><span class="sxs-lookup"><span data-stu-id="c6158-118">Physical partition</span></span>

<span data-ttu-id="c6158-119">A *physical* partition is a fixed amount of reserved SSD-backed storage combined with variable amount of compute resources (CPU and memory).</span><span class="sxs-lookup"><span data-stu-id="c6158-119">A *physical* partition is a fixed amount of reserved SSD-backed storage combined with variable amount of compute resources (CPU and memory).</span></span> <span data-ttu-id="c6158-120">Each physical partition is replicated for high availability.</span><span class="sxs-lookup"><span data-stu-id="c6158-120">Each physical partition is replicated for high availability.</span></span> <span data-ttu-id="c6158-121">Each set of containers may share one or more physical partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-121">Each set of containers may share one or more physical partitions.</span></span> <span data-ttu-id="c6158-122">Physical partition management is fully managed by Azure Cosmos DB, and you don't have to write complex code or manage your partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-122">Physical partition management is fully managed by Azure Cosmos DB, and you don't have to write complex code or manage your partitions.</span></span> <span data-ttu-id="c6158-123">Azure Cosmos DB containers are unlimited in terms of storage and throughput.</span><span class="sxs-lookup"><span data-stu-id="c6158-123">Azure Cosmos DB containers are unlimited in terms of storage and throughput.</span></span> <span data-ttu-id="c6158-124">Physical partitions are an internal concept of Azure Cosmos DB and are transient.</span><span class="sxs-lookup"><span data-stu-id="c6158-124">Physical partitions are an internal concept of Azure Cosmos DB and are transient.</span></span> <span data-ttu-id="c6158-125">Azure Cosmos DB will automatically scale the number of physical partitions based on your workload.</span><span class="sxs-lookup"><span data-stu-id="c6158-125">Azure Cosmos DB will automatically scale the number of physical partitions based on your workload.</span></span> <span data-ttu-id="c6158-126">So you shouldn’t corelate your database design based on the number of physical partitions instead you should make sure to choose the right partition key which determines the logical partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-126">So you shouldn’t corelate your database design based on the number of physical partitions instead you should make sure to choose the right partition key which determines the logical partitions.</span></span> 

### <a name="logical-partition"></a><span data-ttu-id="c6158-127">Logical partition</span><span class="sxs-lookup"><span data-stu-id="c6158-127">Logical partition</span></span>

<span data-ttu-id="c6158-128">A *logical* partition is a partition within a physical partition that stores all the data associated with a single partition key value.</span><span class="sxs-lookup"><span data-stu-id="c6158-128">A *logical* partition is a partition within a physical partition that stores all the data associated with a single partition key value.</span></span> <span data-ttu-id="c6158-129">Multiple logical partitions can end up in the same physical partition.</span><span class="sxs-lookup"><span data-stu-id="c6158-129">Multiple logical partitions can end up in the same physical partition.</span></span> <span data-ttu-id="c6158-130">In the following diagram, a single container has three logical partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-130">In the following diagram, a single container has three logical partitions.</span></span> <span data-ttu-id="c6158-131">Each logical partition stores the data for one partition key, LAX, AMS, and MEL respectively.</span><span class="sxs-lookup"><span data-stu-id="c6158-131">Each logical partition stores the data for one partition key, LAX, AMS, and MEL respectively.</span></span> <span data-ttu-id="c6158-132">Each of the LAX, AMS, and MEL logical partitions cannot grow beyond the maximum logical partition limit of 10 GB.</span><span class="sxs-lookup"><span data-stu-id="c6158-132">Each of the LAX, AMS, and MEL logical partitions cannot grow beyond the maximum logical partition limit of 10 GB.</span></span> 

![Resource partitioning](./media/introduction/azure-cosmos-db-partitioning.png) 

<span data-ttu-id="c6158-134">When a container meets the [partitioning prerequisites](#prerequisites), partitioning is completely transparent to your application.</span><span class="sxs-lookup"><span data-stu-id="c6158-134">When a container meets the [partitioning prerequisites](#prerequisites), partitioning is completely transparent to your application.</span></span> <span data-ttu-id="c6158-135">Azure Cosmos DB handles distributing data across physical and logical partitions and routing of query requests to the right partition.</span><span class="sxs-lookup"><span data-stu-id="c6158-135">Azure Cosmos DB handles distributing data across physical and logical partitions and routing of query requests to the right partition.</span></span> 

## <a name="how-does-partitioning-work"></a><span data-ttu-id="c6158-136">How does partitioning work</span><span class="sxs-lookup"><span data-stu-id="c6158-136">How does partitioning work</span></span>

<span data-ttu-id="c6158-137">Each document must have a *partition key* and a *row key*, which uniquely identify it.</span><span class="sxs-lookup"><span data-stu-id="c6158-137">Each document must have a *partition key* and a *row key*, which uniquely identify it.</span></span> <span data-ttu-id="c6158-138">Your partition key acts as a logical partition for your data and provides Azure Cosmos DB with a natural boundary for distributing data across physical partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-138">Your partition key acts as a logical partition for your data and provides Azure Cosmos DB with a natural boundary for distributing data across physical partitions.</span></span> <span data-ttu-id="c6158-139">**The data for a single logical partition must reside inside a single physical partition and physical partition management is managed by Azure Cosmos DB**.</span><span class="sxs-lookup"><span data-stu-id="c6158-139">**The data for a single logical partition must reside inside a single physical partition and physical partition management is managed by Azure Cosmos DB**.</span></span> 

<span data-ttu-id="c6158-140">In brief, here's how partitioning works in Azure Cosmos DB:</span><span class="sxs-lookup"><span data-stu-id="c6158-140">In brief, here's how partitioning works in Azure Cosmos DB:</span></span>

* <span data-ttu-id="c6158-141">You provision a set of Azure Cosmos DB containers with **T** RU/s (requests per second) throughput.</span><span class="sxs-lookup"><span data-stu-id="c6158-141">You provision a set of Azure Cosmos DB containers with **T** RU/s (requests per second) throughput.</span></span>  
* <span data-ttu-id="c6158-142">Behind the scenes, Azure Cosmos DB provisions physical partitions needed to serve **T** requests per second.</span><span class="sxs-lookup"><span data-stu-id="c6158-142">Behind the scenes, Azure Cosmos DB provisions physical partitions needed to serve **T** requests per second.</span></span> <span data-ttu-id="c6158-143">If **T** is higher than the maximum throughput per physical partition **t**, then Azure Cosmos DB provisions **N = T/t** physical partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-143">If **T** is higher than the maximum throughput per physical partition **t**, then Azure Cosmos DB provisions **N = T/t** physical partitions.</span></span> <span data-ttu-id="c6158-144">The value of maximum throughput per partition(t) is configured by Azure Cosmos DB, this value is assigned based on total provisioned throughput and the hardware configuration used.</span><span class="sxs-lookup"><span data-stu-id="c6158-144">The value of maximum throughput per partition(t) is configured by Azure Cosmos DB, this value is assigned based on total provisioned throughput and the hardware configuration used.</span></span>  
* <span data-ttu-id="c6158-145">Azure Cosmos DB allocates the key space of partition key hashes evenly across the **N** physical partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-145">Azure Cosmos DB allocates the key space of partition key hashes evenly across the **N** physical partitions.</span></span> <span data-ttu-id="c6158-146">So, the number of logical partitions each physical partition hosts is **1/N** \* number of partition key values.</span><span class="sxs-lookup"><span data-stu-id="c6158-146">So, the number of logical partitions each physical partition hosts is **1/N** \* number of partition key values.</span></span>  
* <span data-ttu-id="c6158-147">When a physical partition **p** reaches its storage limit, Azure Cosmos DB seamlessly splits **p** into two new physical partitions, **p1** and **p2**.</span><span class="sxs-lookup"><span data-stu-id="c6158-147">When a physical partition **p** reaches its storage limit, Azure Cosmos DB seamlessly splits **p** into two new physical partitions, **p1** and **p2**.</span></span> <span data-ttu-id="c6158-148">It distributes values corresponding to roughly half of the keys to each of the new physical partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-148">It distributes values corresponding to roughly half of the keys to each of the new physical partitions.</span></span> <span data-ttu-id="c6158-149">This split operation is completely invisible to your application.</span><span class="sxs-lookup"><span data-stu-id="c6158-149">This split operation is completely invisible to your application.</span></span> <span data-ttu-id="c6158-150">If a physical partition reaches its storage limit and all of the data in the physical partition belongs to the same logical partition key, the split operation does not occur.</span><span class="sxs-lookup"><span data-stu-id="c6158-150">If a physical partition reaches its storage limit and all of the data in the physical partition belongs to the same logical partition key, the split operation does not occur.</span></span> <span data-ttu-id="c6158-151">This is because all the data for a single logical partition key must reside in the same physical partition.</span><span class="sxs-lookup"><span data-stu-id="c6158-151">This is because all the data for a single logical partition key must reside in the same physical partition.</span></span> <span data-ttu-id="c6158-152">In this case, a different partition key strategy should be employed.</span><span class="sxs-lookup"><span data-stu-id="c6158-152">In this case, a different partition key strategy should be employed.</span></span>  
* <span data-ttu-id="c6158-153">When you provision throughput higher than **t\*N**, Azure Cosmos DB splits one or more of your physical partitions to support the higher throughput.</span><span class="sxs-lookup"><span data-stu-id="c6158-153">When you provision throughput higher than **t\*N**, Azure Cosmos DB splits one or more of your physical partitions to support the higher throughput.</span></span>

<span data-ttu-id="c6158-154">The semantics for partition keys are slightly different to match the semantics of each API, as shown in the following table:</span><span class="sxs-lookup"><span data-stu-id="c6158-154">The semantics for partition keys are slightly different to match the semantics of each API, as shown in the following table:</span></span>

| <span data-ttu-id="c6158-155">API</span><span class="sxs-lookup"><span data-stu-id="c6158-155">API</span></span> | <span data-ttu-id="c6158-156">Partition key</span><span class="sxs-lookup"><span data-stu-id="c6158-156">Partition key</span></span> | <span data-ttu-id="c6158-157">Row key</span><span class="sxs-lookup"><span data-stu-id="c6158-157">Row key</span></span> |
| --- | --- | --- |
| <span data-ttu-id="c6158-158">SQL</span><span class="sxs-lookup"><span data-stu-id="c6158-158">SQL</span></span> | <span data-ttu-id="c6158-159">Custom partition key path</span><span class="sxs-lookup"><span data-stu-id="c6158-159">Custom partition key path</span></span> | <span data-ttu-id="c6158-160">Fixed `id`</span><span class="sxs-lookup"><span data-stu-id="c6158-160">Fixed `id`</span></span> | 
| <span data-ttu-id="c6158-161">MongoDB</span><span class="sxs-lookup"><span data-stu-id="c6158-161">MongoDB</span></span> | <span data-ttu-id="c6158-162">Custom shard key</span><span class="sxs-lookup"><span data-stu-id="c6158-162">Custom shard key</span></span>  | <span data-ttu-id="c6158-163">Fixed `_id`</span><span class="sxs-lookup"><span data-stu-id="c6158-163">Fixed `_id`</span></span> | 
| <span data-ttu-id="c6158-164">Gremlin</span><span class="sxs-lookup"><span data-stu-id="c6158-164">Gremlin</span></span> | <span data-ttu-id="c6158-165">Custom partition key property</span><span class="sxs-lookup"><span data-stu-id="c6158-165">Custom partition key property</span></span> | <span data-ttu-id="c6158-166">Fixed `id`</span><span class="sxs-lookup"><span data-stu-id="c6158-166">Fixed `id`</span></span> | 
| <span data-ttu-id="c6158-167">Table</span><span class="sxs-lookup"><span data-stu-id="c6158-167">Table</span></span> | <span data-ttu-id="c6158-168">Fixed `PartitionKey`</span><span class="sxs-lookup"><span data-stu-id="c6158-168">Fixed `PartitionKey`</span></span> | <span data-ttu-id="c6158-169">Fixed `RowKey`</span><span class="sxs-lookup"><span data-stu-id="c6158-169">Fixed `RowKey`</span></span> | 

<span data-ttu-id="c6158-170">Azure Cosmos DB uses hash-based partitioning.</span><span class="sxs-lookup"><span data-stu-id="c6158-170">Azure Cosmos DB uses hash-based partitioning.</span></span> <span data-ttu-id="c6158-171">When you write an item, Azure Cosmos DB hashes the partition key value and uses the hashed result to determine which partition to store the item in.</span><span class="sxs-lookup"><span data-stu-id="c6158-171">When you write an item, Azure Cosmos DB hashes the partition key value and uses the hashed result to determine which partition to store the item in.</span></span> 

> [!NOTE]
> <span data-ttu-id="c6158-172">Azure Cosmos DB stores all items with the same partition key in the same physical partition.</span><span class="sxs-lookup"><span data-stu-id="c6158-172">Azure Cosmos DB stores all items with the same partition key in the same physical partition.</span></span> 

## <a name="best-practices-when-choosing-a-partition-key"></a><span data-ttu-id="c6158-173">Best practices when choosing a partition key</span><span class="sxs-lookup"><span data-stu-id="c6158-173">Best practices when choosing a partition key</span></span>

<span data-ttu-id="c6158-174">The choice of the partition key is an important decision that you have to make at design time.</span><span class="sxs-lookup"><span data-stu-id="c6158-174">The choice of the partition key is an important decision that you have to make at design time.</span></span> <span data-ttu-id="c6158-175">Pick a property name that has a wide range of values and has even access patterns.</span><span class="sxs-lookup"><span data-stu-id="c6158-175">Pick a property name that has a wide range of values and has even access patterns.</span></span> <span data-ttu-id="c6158-176">It's a best practice to have a partition key with a large number of distinct values (e.g., hundreds or thousands).</span><span class="sxs-lookup"><span data-stu-id="c6158-176">It's a best practice to have a partition key with a large number of distinct values (e.g., hundreds or thousands).</span></span> <span data-ttu-id="c6158-177">It lets you distribute your workload evenly across these values.</span><span class="sxs-lookup"><span data-stu-id="c6158-177">It lets you distribute your workload evenly across these values.</span></span> <span data-ttu-id="c6158-178">An ideal partition key is one that appears frequently as a filter in your queries and has sufficient cardinality to ensure your solution is scalable.</span><span class="sxs-lookup"><span data-stu-id="c6158-178">An ideal partition key is one that appears frequently as a filter in your queries and has sufficient cardinality to ensure your solution is scalable.</span></span>

<span data-ttu-id="c6158-179">If a physical partition reaches its storage limit and the data in the partition has the same partition key, Azure Cosmos DB returns the *"Partition key reached maximum size of 10 GB"* message, and the partition is not split.</span><span class="sxs-lookup"><span data-stu-id="c6158-179">If a physical partition reaches its storage limit and the data in the partition has the same partition key, Azure Cosmos DB returns the *"Partition key reached maximum size of 10 GB"* message, and the partition is not split.</span></span> <span data-ttu-id="c6158-180">Choosing a good partition key is a very important decision.</span><span class="sxs-lookup"><span data-stu-id="c6158-180">Choosing a good partition key is a very important decision.</span></span> 

<span data-ttu-id="c6158-181">Choose a partition key such that:</span><span class="sxs-lookup"><span data-stu-id="c6158-181">Choose a partition key such that:</span></span>

* <span data-ttu-id="c6158-182">The storage distribution is even across all the keys.</span><span class="sxs-lookup"><span data-stu-id="c6158-182">The storage distribution is even across all the keys.</span></span>  
* <span data-ttu-id="c6158-183">Choose a partition key that will evenly distribute data across partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-183">Choose a partition key that will evenly distribute data across partitions.</span></span>

  <span data-ttu-id="c6158-184">It is a good idea to check how your data is distributed across partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-184">It is a good idea to check how your data is distributed across partitions.</span></span> <span data-ttu-id="c6158-185">To check the data distribution in the portal, go to your Azure Cosmos DB account and click on **Metrics** in **Monitoring** section and then click on **storage** tab to see how your data is partitioned across different physical partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-185">To check the data distribution in the portal, go to your Azure Cosmos DB account and click on **Metrics** in **Monitoring** section and then click on **storage** tab to see how your data is partitioned across different physical partitions.</span></span>

  ![Resource partitioning](./media/partition-data/partitionkey-example.png)

  <span data-ttu-id="c6158-187">The left image above shows the result of a bad partition key and the right image above shows the result when a good partition key was chosen.</span><span class="sxs-lookup"><span data-stu-id="c6158-187">The left image above shows the result of a bad partition key and the right image above shows the result when a good partition key was chosen.</span></span> <span data-ttu-id="c6158-188">In the left image, you can see that the data is not evenly distributed across the partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-188">In the left image, you can see that the data is not evenly distributed across the partitions.</span></span> <span data-ttu-id="c6158-189">You should strive to choose a partition key that distributes your data so it looks similar to the right image.</span><span class="sxs-lookup"><span data-stu-id="c6158-189">You should strive to choose a partition key that distributes your data so it looks similar to the right image.</span></span>

* <span data-ttu-id="c6158-190">Optimize queries to obtain data within the boundaries of a partition when possible.</span><span class="sxs-lookup"><span data-stu-id="c6158-190">Optimize queries to obtain data within the boundaries of a partition when possible.</span></span> <span data-ttu-id="c6158-191">An optimal partitioning strategy would be aligned to the querying patterns.</span><span class="sxs-lookup"><span data-stu-id="c6158-191">An optimal partitioning strategy would be aligned to the querying patterns.</span></span> <span data-ttu-id="c6158-192">Queries that obtain data from a single partition provide the best possible performance.</span><span class="sxs-lookup"><span data-stu-id="c6158-192">Queries that obtain data from a single partition provide the best possible performance.</span></span> <span data-ttu-id="c6158-193">Queries that are invoked with high concurrency can be efficiently routed by including the partition key in the filter predicate.</span><span class="sxs-lookup"><span data-stu-id="c6158-193">Queries that are invoked with high concurrency can be efficiently routed by including the partition key in the filter predicate.</span></span>  

* <span data-ttu-id="c6158-194">Choosing a partition key with higher cardinality is generally preferred – becaue it typically yields better distribution and scalability.</span><span class="sxs-lookup"><span data-stu-id="c6158-194">Choosing a partition key with higher cardinality is generally preferred – becaue it typically yields better distribution and scalability.</span></span> <span data-ttu-id="c6158-195">For example, a synthetic key can be formed by concatenating values from multiple properties to increase the cardinality.</span><span class="sxs-lookup"><span data-stu-id="c6158-195">For example, a synthetic key can be formed by concatenating values from multiple properties to increase the cardinality.</span></span>  

<span data-ttu-id="c6158-196">When you choose a partition key with above considerations, you don’t have to worry about the number of partitions or how much throughput is allocated per physical partition, as Azure Cosmos DB scales out the number of physical partitions, and it can also scale the individual partitions as needed.</span><span class="sxs-lookup"><span data-stu-id="c6158-196">When you choose a partition key with above considerations, you don’t have to worry about the number of partitions or how much throughput is allocated per physical partition, as Azure Cosmos DB scales out the number of physical partitions, and it can also scale the individual partitions as needed.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="c6158-197">Prerequisites for partitioning</span><span class="sxs-lookup"><span data-stu-id="c6158-197">Prerequisites for partitioning</span></span>

<span data-ttu-id="c6158-198">Azure Cosmos DB containers can be created as fixed or unlimited in the Azure portal.</span><span class="sxs-lookup"><span data-stu-id="c6158-198">Azure Cosmos DB containers can be created as fixed or unlimited in the Azure portal.</span></span> <span data-ttu-id="c6158-199">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span><span class="sxs-lookup"><span data-stu-id="c6158-199">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="c6158-200">To create a container as unlimited, you must specify a partition key and a minimum throughput of 1,000 RU/s.</span><span class="sxs-lookup"><span data-stu-id="c6158-200">To create a container as unlimited, you must specify a partition key and a minimum throughput of 1,000 RU/s.</span></span> <span data-ttu-id="c6158-201">Azure Cosmos DB containers may also be configured to share throughput between a set of containers, in which each container must specificy a partition key and can grow unlimited.</span><span class="sxs-lookup"><span data-stu-id="c6158-201">Azure Cosmos DB containers may also be configured to share throughput between a set of containers, in which each container must specificy a partition key and can grow unlimited.</span></span> <span data-ttu-id="c6158-202">Following are the prerequisites to consider for partitioning and scaling:</span><span class="sxs-lookup"><span data-stu-id="c6158-202">Following are the prerequisites to consider for partitioning and scaling:</span></span>

* <span data-ttu-id="c6158-203">When creating a container (e.g., a collection, a graph or a table) in the Azure portal, select the **Unlimited** storage capacity option to take advantage of unlimited scaling.</span><span class="sxs-lookup"><span data-stu-id="c6158-203">When creating a container (e.g., a collection, a graph or a table) in the Azure portal, select the **Unlimited** storage capacity option to take advantage of unlimited scaling.</span></span> <span data-ttu-id="c6158-204">For physical partitions to auto-split into **p1** and **p2** as described in [How does partitioning work](#how-does-partitioning-work), the container must be created with a throughput of 1,000 RU/s or more (or share throughput across a set of containers), and a partition key must be provided.</span><span class="sxs-lookup"><span data-stu-id="c6158-204">For physical partitions to auto-split into **p1** and **p2** as described in [How does partitioning work](#how-does-partitioning-work), the container must be created with a throughput of 1,000 RU/s or more (or share throughput across a set of containers), and a partition key must be provided.</span></span> 

* <span data-ttu-id="c6158-205">If you created a container in the Azure portal or programmatically and the initial throughput was 1,000 RU/s or more, and you provided a partition key, you can take advantage of unlimited scaling with no changes to your container.</span><span class="sxs-lookup"><span data-stu-id="c6158-205">If you created a container in the Azure portal or programmatically and the initial throughput was 1,000 RU/s or more, and you provided a partition key, you can take advantage of unlimited scaling with no changes to your container.</span></span> <span data-ttu-id="c6158-206">This includes **Fixed** containers, so long as the initial container was created with at least 1,000 RU/s of throughput and a partition key is specified.</span><span class="sxs-lookup"><span data-stu-id="c6158-206">This includes **Fixed** containers, so long as the initial container was created with at least 1,000 RU/s of throughput and a partition key is specified.</span></span>

* <span data-ttu-id="c6158-207">All containers configured to share throughput as part of a set of containers are treated as **Unlimited** containers.</span><span class="sxs-lookup"><span data-stu-id="c6158-207">All containers configured to share throughput as part of a set of containers are treated as **Unlimited** containers.</span></span>

<span data-ttu-id="c6158-208">If you created a **Fixed** container with no partition key or throughput less than 1,000 RU/s, the container will not auto-scale.</span><span class="sxs-lookup"><span data-stu-id="c6158-208">If you created a **Fixed** container with no partition key or throughput less than 1,000 RU/s, the container will not auto-scale.</span></span> <span data-ttu-id="c6158-209">To migrate the data from a fixed container to an unlimited container, you need to use the [Data Migration tool](import-data.md) or the [Change Feed library](change-feed.md).</span><span class="sxs-lookup"><span data-stu-id="c6158-209">To migrate the data from a fixed container to an unlimited container, you need to use the [Data Migration tool](import-data.md) or the [Change Feed library](change-feed.md).</span></span> 

## <a name="PartitionedGraph"></a><span data-ttu-id="c6158-210">Requirements for partitioned graph</span><span class="sxs-lookup"><span data-stu-id="c6158-210">Requirements for partitioned graph</span></span>

<span data-ttu-id="c6158-211">Consider the following details when creating a partitioned graph container:</span><span class="sxs-lookup"><span data-stu-id="c6158-211">Consider the following details when creating a partitioned graph container:</span></span>

- <span data-ttu-id="c6158-212">**Setting up partitioning is necessary** if the container is expected to be more than 10 GB in size and/or if allocating more than 10,000 request units per second (RU/s) will be required.</span><span class="sxs-lookup"><span data-stu-id="c6158-212">**Setting up partitioning is necessary** if the container is expected to be more than 10 GB in size and/or if allocating more than 10,000 request units per second (RU/s) will be required.</span></span>

- <span data-ttu-id="c6158-213">**Vertices and edges are stored as JSON documents** in the back-end of an Azure Cosmos DB Gremlin API.</span><span class="sxs-lookup"><span data-stu-id="c6158-213">**Vertices and edges are stored as JSON documents** in the back-end of an Azure Cosmos DB Gremlin API.</span></span>

- <span data-ttu-id="c6158-214">**Vertices require a partition key**.</span><span class="sxs-lookup"><span data-stu-id="c6158-214">**Vertices require a partition key**.</span></span> <span data-ttu-id="c6158-215">This key determines which partition is used to store the vertex and this process uses a hashing algorithm.</span><span class="sxs-lookup"><span data-stu-id="c6158-215">This key determines which partition is used to store the vertex and this process uses a hashing algorithm.</span></span> <span data-ttu-id="c6158-216">The name of this partition key is a single-word string without spaces or special characters, and it is defined when creating a new container using the format `/partitioning-key-name`.</span><span class="sxs-lookup"><span data-stu-id="c6158-216">The name of this partition key is a single-word string without spaces or special characters, and it is defined when creating a new container using the format `/partitioning-key-name`.</span></span>

- <span data-ttu-id="c6158-217">**Edges are stored with their source vertex**.</span><span class="sxs-lookup"><span data-stu-id="c6158-217">**Edges are stored with their source vertex**.</span></span> <span data-ttu-id="c6158-218">In other words, for each vertex its partition key defines where the vertex and its outgoing edges are stored.</span><span class="sxs-lookup"><span data-stu-id="c6158-218">In other words, for each vertex its partition key defines where the vertex and its outgoing edges are stored.</span></span> <span data-ttu-id="c6158-219">This is done to avoid cross-partition queries when using the `out()` cardinality in graph queries.</span><span class="sxs-lookup"><span data-stu-id="c6158-219">This is done to avoid cross-partition queries when using the `out()` cardinality in graph queries.</span></span>

- <span data-ttu-id="c6158-220">**Graph queries should specify a partition key**.</span><span class="sxs-lookup"><span data-stu-id="c6158-220">**Graph queries should specify a partition key**.</span></span> <span data-ttu-id="c6158-221">To take full advantage of the horizontal partitioning in Azure Cosmos DB, whenever it's possible the graph queries should include partition key.</span><span class="sxs-lookup"><span data-stu-id="c6158-221">To take full advantage of the horizontal partitioning in Azure Cosmos DB, whenever it's possible the graph queries should include partition key.</span></span> <span data-ttu-id="c6158-222">For example when a single vertex is selected.</span><span class="sxs-lookup"><span data-stu-id="c6158-222">For example when a single vertex is selected.</span></span> <span data-ttu-id="c6158-223">The following example queries show how to include partition key when selecting one or multiple vertices in a partitioned graph:</span><span class="sxs-lookup"><span data-stu-id="c6158-223">The following example queries show how to include partition key when selecting one or multiple vertices in a partitioned graph:</span></span>

    - <span data-ttu-id="c6158-224">Selecting a vertex by ID, then **use the `.has()` step to specify the partition key property**:</span><span class="sxs-lookup"><span data-stu-id="c6158-224">Selecting a vertex by ID, then **use the `.has()` step to specify the partition key property**:</span></span> 
    
        ```
        g.V('vertex_id').has('partitionKey', 'partitionKey_value')
        ```
    
    - <span data-ttu-id="c6158-225">Selecting a vertex by **specifying a tuple including partition key value and ID**:</span><span class="sxs-lookup"><span data-stu-id="c6158-225">Selecting a vertex by **specifying a tuple including partition key value and ID**:</span></span> 
    
        ```
        g.V(['partitionKey_value', 'vertex_id'])
        ```
        
    - <span data-ttu-id="c6158-226">Selecting a vertex by specifying an **array of tuples that include partition key values and IDs**:</span><span class="sxs-lookup"><span data-stu-id="c6158-226">Selecting a vertex by specifying an **array of tuples that include partition key values and IDs**:</span></span>
    
        ```
        g.V(['partitionKey_value0', 'verted_id0'], ['partitionKey_value1', 'vertex_id1'], ...)
        ```
        
    - <span data-ttu-id="c6158-227">Selecting a set of vertices by **specifying a list of partition key values**:</span><span class="sxs-lookup"><span data-stu-id="c6158-227">Selecting a set of vertices by **specifying a list of partition key values**:</span></span> 
    
        ```
        g.V('vertex_id0', 'vertex_id1', 'vertex_id2', …).has('partitionKey', within('partitionKey_value0', 'partitionKey_value01', 'partitionKey_value02', …)
        ```

* <span data-ttu-id="c6158-228">**Always specify the partition key value when querying a vertex**.</span><span class="sxs-lookup"><span data-stu-id="c6158-228">**Always specify the partition key value when querying a vertex**.</span></span> <span data-ttu-id="c6158-229">Obtaining a vertex from a known partition is the most efficient way in terms of performance.</span><span class="sxs-lookup"><span data-stu-id="c6158-229">Obtaining a vertex from a known partition is the most efficient way in terms of performance.</span></span>

* <span data-ttu-id="c6158-230">**Use the outgoing direction when querying edges** whenever it's possible.</span><span class="sxs-lookup"><span data-stu-id="c6158-230">**Use the outgoing direction when querying edges** whenever it's possible.</span></span> <span data-ttu-id="c6158-231">Edges are stored with their source vertices in the outgoing direction.</span><span class="sxs-lookup"><span data-stu-id="c6158-231">Edges are stored with their source vertices in the outgoing direction.</span></span> <span data-ttu-id="c6158-232">This means that the chances of resorting to cross-partition queries are minimized when the data and queries are designed with this pattern in mind.</span><span class="sxs-lookup"><span data-stu-id="c6158-232">This means that the chances of resorting to cross-partition queries are minimized when the data and queries are designed with this pattern in mind.</span></span>

## <a name="designing-for-partitioning"></a> <span data-ttu-id="c6158-233">Create partition key</span><span class="sxs-lookup"><span data-stu-id="c6158-233">Create partition key</span></span> 
<span data-ttu-id="c6158-234">You can use the Azure portal or Azure CLI to create containers and scale them at any time.</span><span class="sxs-lookup"><span data-stu-id="c6158-234">You can use the Azure portal or Azure CLI to create containers and scale them at any time.</span></span> <span data-ttu-id="c6158-235">This section shows how to create containers and specify the provisioned throughput and partition key using each API.</span><span class="sxs-lookup"><span data-stu-id="c6158-235">This section shows how to create containers and specify the provisioned throughput and partition key using each API.</span></span>


### <a name="sql-api"></a><span data-ttu-id="c6158-236">SQL API</span><span class="sxs-lookup"><span data-stu-id="c6158-236">SQL API</span></span>
<span data-ttu-id="c6158-237">The following sample shows how to create a container (a collection) using SQL API.</span><span class="sxs-lookup"><span data-stu-id="c6158-237">The following sample shows how to create a container (a collection) using SQL API.</span></span> 

```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
await client.CreateDatabaseAsync(new Database { Id = "db" });

DocumentCollection myCollection = new DocumentCollection();
myCollection.Id = "coll";
myCollection.PartitionKey.Paths.Add("/deviceId");

await client.CreateDocumentCollectionAsync(
    UriFactory.CreateDatabaseUri("db"),
    myCollection,
    new RequestOptions { OfferThroughput = 20000 });
```

<span data-ttu-id="c6158-238">You can read an item (document) using the `GET` method in the REST API or using `ReadDocumentAsync` in one of the SDKs.</span><span class="sxs-lookup"><span data-stu-id="c6158-238">You can read an item (document) using the `GET` method in the REST API or using `ReadDocumentAsync` in one of the SDKs.</span></span>

```csharp
// Read document. Needs the partition key and the ID to be specified
DeviceReading document = await client.ReadDocumentAsync<DeviceReading>(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });
```

<span data-ttu-id="c6158-239">For more information, see [Partitioning in Azure Cosmos DB using the SQL API](sql-api-partition-data.md).</span><span class="sxs-lookup"><span data-stu-id="c6158-239">For more information, see [Partitioning in Azure Cosmos DB using the SQL API](sql-api-partition-data.md).</span></span>

### <a name="mongodb-api"></a><span data-ttu-id="c6158-240">MongoDB API</span><span class="sxs-lookup"><span data-stu-id="c6158-240">MongoDB API</span></span>
<span data-ttu-id="c6158-241">With the MongoDB API, you can create a sharded collection through your favorite tool, driver, or SDK.</span><span class="sxs-lookup"><span data-stu-id="c6158-241">With the MongoDB API, you can create a sharded collection through your favorite tool, driver, or SDK.</span></span> <span data-ttu-id="c6158-242">In this example, we use the Mongo Shell to create a collection.</span><span class="sxs-lookup"><span data-stu-id="c6158-242">In this example, we use the Mongo Shell to create a collection.</span></span>

<span data-ttu-id="c6158-243">In the Mongo Shell:</span><span class="sxs-lookup"><span data-stu-id="c6158-243">In the Mongo Shell:</span></span>

```
db.runCommand( { shardCollection: "admin.people", key: { region: "hashed" } } )
```
    
<span data-ttu-id="c6158-244">Results:</span><span class="sxs-lookup"><span data-stu-id="c6158-244">Results:</span></span>

```JSON
{
    "_t" : "ShardCollectionResponse",
    "ok" : 1,
    "collectionsharded" : "admin.people"
}
```

### <a name="table-api"></a><span data-ttu-id="c6158-245">Table API</span><span class="sxs-lookup"><span data-stu-id="c6158-245">Table API</span></span>

<span data-ttu-id="c6158-246">To create a table using the Table API, use the `CreateIfNotExists` method.</span><span class="sxs-lookup"><span data-stu-id="c6158-246">To create a table using the Table API, use the `CreateIfNotExists` method.</span></span> 

```csharp
CloudTableClient tableClient = storageAccount.CreateCloudTableClient();

CloudTable table = tableClient.GetTableReference("people");
table.CreateIfNotExists(throughput: 800);
```

<span data-ttu-id="c6158-247">Provisioned throughput is set as an argument of `CreateIfNotExists`.</span><span class="sxs-lookup"><span data-stu-id="c6158-247">Provisioned throughput is set as an argument of `CreateIfNotExists`.</span></span> <span data-ttu-id="c6158-248">The partition key is implicitly created as the `PartitionKey` value.</span><span class="sxs-lookup"><span data-stu-id="c6158-248">The partition key is implicitly created as the `PartitionKey` value.</span></span> 

<span data-ttu-id="c6158-249">You can retrieve a single entity by using the following code:</span><span class="sxs-lookup"><span data-stu-id="c6158-249">You can retrieve a single entity by using the following code:</span></span>

```csharp
// Create a retrieve operation that takes a customer entity.
TableOperation retrieveOperation = TableOperation.Retrieve<CustomerEntity>("Smith", "Ben");

// Execute the retrieve operation.
TableResult retrievedResult = table.Execute(retrieveOperation);
```
<span data-ttu-id="c6158-250">For more information, see [Develop with the Table API](tutorial-develop-table-dotnet.md).</span><span class="sxs-lookup"><span data-stu-id="c6158-250">For more information, see [Develop with the Table API](tutorial-develop-table-dotnet.md).</span></span>

### <a name="gremlin-api"></a><span data-ttu-id="c6158-251">Gremlin API</span><span class="sxs-lookup"><span data-stu-id="c6158-251">Gremlin API</span></span>

<span data-ttu-id="c6158-252">With the Gremlin API, you can use the Azure portal or Azure CLI to create a container that represents a graph.</span><span class="sxs-lookup"><span data-stu-id="c6158-252">With the Gremlin API, you can use the Azure portal or Azure CLI to create a container that represents a graph.</span></span> <span data-ttu-id="c6158-253">Alternatively, because Azure Cosmos DB is multi-model, you can use one of the other APIs to create and scale your graph container.</span><span class="sxs-lookup"><span data-stu-id="c6158-253">Alternatively, because Azure Cosmos DB is multi-model, you can use one of the other APIs to create and scale your graph container.</span></span>

<span data-ttu-id="c6158-254">You can read any vertex or edge by using the partition key and ID in Gremlin.</span><span class="sxs-lookup"><span data-stu-id="c6158-254">You can read any vertex or edge by using the partition key and ID in Gremlin.</span></span> <span data-ttu-id="c6158-255">For example, for a graph with region ("USA") as the partition key and "Seattle" as the row key, you can find a vertex by using the following syntax:</span><span class="sxs-lookup"><span data-stu-id="c6158-255">For example, for a graph with region ("USA") as the partition key and "Seattle" as the row key, you can find a vertex by using the following syntax:</span></span>

```
g.V(['USA', 'Seattle'])
```

<span data-ttu-id="c6158-256">You can reference an edge by using the partition key and the row key.</span><span class="sxs-lookup"><span data-stu-id="c6158-256">You can reference an edge by using the partition key and the row key.</span></span>

```
g.E(['USA', 'I5'])
```

<span data-ttu-id="c6158-257">For more information, see [Using a partitioned graph in Azure Cosmos DB](graph-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="c6158-257">For more information, see [Using a partitioned graph in Azure Cosmos DB](graph-partitioning.md).</span></span>

## <a name="form-partition-key-by-concatenating-multiple-fields"></a><span data-ttu-id="c6158-258">Form partition key by concatenating multiple fields</span><span class="sxs-lookup"><span data-stu-id="c6158-258">Form partition key by concatenating multiple fields</span></span>

<span data-ttu-id="c6158-259">You can also form a partition key by concatenating and padding multiple property values into a single artificial "partitionKey" property of the item.</span><span class="sxs-lookup"><span data-stu-id="c6158-259">You can also form a partition key by concatenating and padding multiple property values into a single artificial "partitionKey" property of the item.</span></span> <span data-ttu-id="c6158-260">These keys are referred as synthetic keys.</span><span class="sxs-lookup"><span data-stu-id="c6158-260">These keys are referred as synthetic keys.</span></span>

<span data-ttu-id="c6158-261">For example, you have a document that looks like:</span><span class="sxs-lookup"><span data-stu-id="c6158-261">For example, you have a document that looks like:</span></span>

```json
{
"deviceId": "abc-123",
"date": 2018
}
```

<span data-ttu-id="c6158-262">One option is to set partitionKey on /deviceId or /date.</span><span class="sxs-lookup"><span data-stu-id="c6158-262">One option is to set partitionKey on /deviceId or /date.</span></span> <span data-ttu-id="c6158-263">If want to form a partition key on device id and date.</span><span class="sxs-lookup"><span data-stu-id="c6158-263">If want to form a partition key on device id and date.</span></span> <span data-ttu-id="c6158-264">Concatenate these two values in to an artificial "partitionKey" property, and set the partition key to /partitionKey.</span><span class="sxs-lookup"><span data-stu-id="c6158-264">Concatenate these two values in to an artificial "partitionKey" property, and set the partition key to /partitionKey.</span></span>

```json
{
"deviceId": "abc-123",
"date": 2018,
"partitionKey": "abc-123-2018"
}
```

<span data-ttu-id="c6158-265">In real time scenarios you can have thousands of documents so you should define client side logic to concatenate values into a synthetic key, insert the synthetic key into the documents and then use it to specify partition key.</span><span class="sxs-lookup"><span data-stu-id="c6158-265">In real time scenarios you can have thousands of documents so you should define client side logic to concatenate values into a synthetic key, insert the synthetic key into the documents and then use it to specify partition key.</span></span>

## <a name="designing-for-scale"></a> <span data-ttu-id="c6158-266">Design for scale</span><span class="sxs-lookup"><span data-stu-id="c6158-266">Design for scale</span></span>
<span data-ttu-id="c6158-267">To scale effectively with Azure Cosmos DB, you need to pick a good partition key when you create your container.</span><span class="sxs-lookup"><span data-stu-id="c6158-267">To scale effectively with Azure Cosmos DB, you need to pick a good partition key when you create your container.</span></span> <span data-ttu-id="c6158-268">There are two main considerations for choosing a good partition key:</span><span class="sxs-lookup"><span data-stu-id="c6158-268">There are two main considerations for choosing a good partition key:</span></span>

* <span data-ttu-id="c6158-269">**Query boundary and transactions**.</span><span class="sxs-lookup"><span data-stu-id="c6158-269">**Query boundary and transactions**.</span></span> <span data-ttu-id="c6158-270">Your choice of partition key should balance the need to use transactions against the requirement to distribute your entities across multiple partition keys to ensure a scalable solution.</span><span class="sxs-lookup"><span data-stu-id="c6158-270">Your choice of partition key should balance the need to use transactions against the requirement to distribute your entities across multiple partition keys to ensure a scalable solution.</span></span> <span data-ttu-id="c6158-271">At one extreme, you can set the same partition key for all your items, but this option might limit the scalability of your solution.</span><span class="sxs-lookup"><span data-stu-id="c6158-271">At one extreme, you can set the same partition key for all your items, but this option might limit the scalability of your solution.</span></span> <span data-ttu-id="c6158-272">At the other extreme, you can assign a unique partition key for each item.</span><span class="sxs-lookup"><span data-stu-id="c6158-272">At the other extreme, you can assign a unique partition key for each item.</span></span> <span data-ttu-id="c6158-273">This choice is highly scalable, but it prevents you from using cross-document transactions via stored procedures and triggers.</span><span class="sxs-lookup"><span data-stu-id="c6158-273">This choice is highly scalable, but it prevents you from using cross-document transactions via stored procedures and triggers.</span></span> <span data-ttu-id="c6158-274">An ideal partition key enables you to use efficient queries and has sufficient cardinality to ensure your solution is scalable.</span><span class="sxs-lookup"><span data-stu-id="c6158-274">An ideal partition key enables you to use efficient queries and has sufficient cardinality to ensure your solution is scalable.</span></span> 
* <span data-ttu-id="c6158-275">**No storage and performance bottlenecks**.</span><span class="sxs-lookup"><span data-stu-id="c6158-275">**No storage and performance bottlenecks**.</span></span> <span data-ttu-id="c6158-276">It's important to pick a property that allows writes to be distributed across various distinct values.</span><span class="sxs-lookup"><span data-stu-id="c6158-276">It's important to pick a property that allows writes to be distributed across various distinct values.</span></span> <span data-ttu-id="c6158-277">Requests to the same partition key can't exceed the provisioned throughput allocated to a partition and will be rate-limited.</span><span class="sxs-lookup"><span data-stu-id="c6158-277">Requests to the same partition key can't exceed the provisioned throughput allocated to a partition and will be rate-limited.</span></span> <span data-ttu-id="c6158-278">So it's important to pick a partition key that doesn't result in "hot spots" within your application.</span><span class="sxs-lookup"><span data-stu-id="c6158-278">So it's important to pick a partition key that doesn't result in "hot spots" within your application.</span></span> <span data-ttu-id="c6158-279">Because all the data for a single partition key must be stored within a partition, you should avoid partition keys that have high volumes of data for the same value.</span><span class="sxs-lookup"><span data-stu-id="c6158-279">Because all the data for a single partition key must be stored within a partition, you should avoid partition keys that have high volumes of data for the same value.</span></span> 

<span data-ttu-id="c6158-280">Let's look at a few real-world scenarios and good partition keys for each:</span><span class="sxs-lookup"><span data-stu-id="c6158-280">Let's look at a few real-world scenarios and good partition keys for each:</span></span>
* <span data-ttu-id="c6158-281">If you're implementing a user profile backend, the *user ID* is a good choice for a partition key.</span><span class="sxs-lookup"><span data-stu-id="c6158-281">If you're implementing a user profile backend, the *user ID* is a good choice for a partition key.</span></span>
* <span data-ttu-id="c6158-282">If you're storing IoT data, for example, device state, a *device ID* is a good choice for a partition key.</span><span class="sxs-lookup"><span data-stu-id="c6158-282">If you're storing IoT data, for example, device state, a *device ID* is a good choice for a partition key.</span></span>
* <span data-ttu-id="c6158-283">If you're using Azure Cosmos DB for logging time-series data, the *hostname* or *process ID* is a good choice for a partition key.</span><span class="sxs-lookup"><span data-stu-id="c6158-283">If you're using Azure Cosmos DB for logging time-series data, the *hostname* or *process ID* is a good choice for a partition key.</span></span>
* <span data-ttu-id="c6158-284">If you have a multitenant architecture, the *tenant ID* is a good choice for a partition key.</span><span class="sxs-lookup"><span data-stu-id="c6158-284">If you have a multitenant architecture, the *tenant ID* is a good choice for a partition key.</span></span>

<span data-ttu-id="c6158-285">In some use cases, like IoT and user profiles, the partition key might be the same as your *ID* (document key).</span><span class="sxs-lookup"><span data-stu-id="c6158-285">In some use cases, like IoT and user profiles, the partition key might be the same as your *ID* (document key).</span></span> <span data-ttu-id="c6158-286">In others, like the time-series data, you might have a partition key that's different from the *ID*.</span><span class="sxs-lookup"><span data-stu-id="c6158-286">In others, like the time-series data, you might have a partition key that's different from the *ID*.</span></span>

### <a name="partitioning-and-loggingtime-series-data"></a><span data-ttu-id="c6158-287">Partitioning and logging/time-series data</span><span class="sxs-lookup"><span data-stu-id="c6158-287">Partitioning and logging/time-series data</span></span>
<span data-ttu-id="c6158-288">One of the common use cases in Azure Cosmos DB is logging and telemetry.</span><span class="sxs-lookup"><span data-stu-id="c6158-288">One of the common use cases in Azure Cosmos DB is logging and telemetry.</span></span> <span data-ttu-id="c6158-289">It's important to pick a good partition key in this scenario, because you might need to read/write vast volumes of data.</span><span class="sxs-lookup"><span data-stu-id="c6158-289">It's important to pick a good partition key in this scenario, because you might need to read/write vast volumes of data.</span></span> <span data-ttu-id="c6158-290">The choice for a partition key depends on your read-and-write rates and the kinds of queries you expect to run.</span><span class="sxs-lookup"><span data-stu-id="c6158-290">The choice for a partition key depends on your read-and-write rates and the kinds of queries you expect to run.</span></span> <span data-ttu-id="c6158-291">Here are some tips on how to choose a good partition key:</span><span class="sxs-lookup"><span data-stu-id="c6158-291">Here are some tips on how to choose a good partition key:</span></span>

* <span data-ttu-id="c6158-292">If your use case involves a small rate of writes that accumulate over a long time and you need to query by ranges of timestamps with other filters, use a rollup of the timestamp.</span><span class="sxs-lookup"><span data-stu-id="c6158-292">If your use case involves a small rate of writes that accumulate over a long time and you need to query by ranges of timestamps with other filters, use a rollup of the timestamp.</span></span> <span data-ttu-id="c6158-293">For example, a good approach is to use date as a partition key.</span><span class="sxs-lookup"><span data-stu-id="c6158-293">For example, a good approach is to use date as a partition key.</span></span> <span data-ttu-id="c6158-294">With this approach, you can query over all the data for a given date from a single partition.</span><span class="sxs-lookup"><span data-stu-id="c6158-294">With this approach, you can query over all the data for a given date from a single partition.</span></span> 
* <span data-ttu-id="c6158-295">If your workload is write-heavy, which is very common in this scenario, use a partition key that is not based on the timestamp.</span><span class="sxs-lookup"><span data-stu-id="c6158-295">If your workload is write-heavy, which is very common in this scenario, use a partition key that is not based on the timestamp.</span></span> <span data-ttu-id="c6158-296">As such, Azure Cosmos DB can distribute and scale writes evenly across various partitions.</span><span class="sxs-lookup"><span data-stu-id="c6158-296">As such, Azure Cosmos DB can distribute and scale writes evenly across various partitions.</span></span> <span data-ttu-id="c6158-297">Here a *hostname*, *process ID*, *activity ID*, or another property with high cardinality is a good choice.</span><span class="sxs-lookup"><span data-stu-id="c6158-297">Here a *hostname*, *process ID*, *activity ID*, or another property with high cardinality is a good choice.</span></span> 
* <span data-ttu-id="c6158-298">Another approach is a hybrid approach, where you have multiple containers, one for each day/month, and the partition key is a more granular property like *hostname*.</span><span class="sxs-lookup"><span data-stu-id="c6158-298">Another approach is a hybrid approach, where you have multiple containers, one for each day/month, and the partition key is a more granular property like *hostname*.</span></span> <span data-ttu-id="c6158-299">This approach has the benefit that you can set different throughput for each container or a set of containers based on the time window and the scale and performance needs.</span><span class="sxs-lookup"><span data-stu-id="c6158-299">This approach has the benefit that you can set different throughput for each container or a set of containers based on the time window and the scale and performance needs.</span></span> <span data-ttu-id="c6158-300">For example, a container for the current month may be provisioned with a higher throughput, because it serves reads and writes.</span><span class="sxs-lookup"><span data-stu-id="c6158-300">For example, a container for the current month may be provisioned with a higher throughput, because it serves reads and writes.</span></span> <span data-ttu-id="c6158-301">Previous months may be provisioned with a lower throughput, because they only serve reads.</span><span class="sxs-lookup"><span data-stu-id="c6158-301">Previous months may be provisioned with a lower throughput, because they only serve reads.</span></span>

### <a name="partitioning-and-multitenancy"></a><span data-ttu-id="c6158-302">Partitioning and multitenancy</span><span class="sxs-lookup"><span data-stu-id="c6158-302">Partitioning and multitenancy</span></span>
<span data-ttu-id="c6158-303">If you are implementing a multitenant application using Azure Cosmos DB, there are two popular designs to consider: *one partition key per tenant* and *one container per tenant*.</span><span class="sxs-lookup"><span data-stu-id="c6158-303">If you are implementing a multitenant application using Azure Cosmos DB, there are two popular designs to consider: *one partition key per tenant* and *one container per tenant*.</span></span> <span data-ttu-id="c6158-304">Here are the pros and cons for each:</span><span class="sxs-lookup"><span data-stu-id="c6158-304">Here are the pros and cons for each:</span></span>

* <span data-ttu-id="c6158-305">**One partition key per tenant**.</span><span class="sxs-lookup"><span data-stu-id="c6158-305">**One partition key per tenant**.</span></span> <span data-ttu-id="c6158-306">In this model, tenants are colocated within a single container.</span><span class="sxs-lookup"><span data-stu-id="c6158-306">In this model, tenants are colocated within a single container.</span></span> <span data-ttu-id="c6158-307">Queries and inserts for a single tenant can be performed against a single partition.</span><span class="sxs-lookup"><span data-stu-id="c6158-307">Queries and inserts for a single tenant can be performed against a single partition.</span></span> <span data-ttu-id="c6158-308">You can also implement transactional logic across all items belonging to a tenant.</span><span class="sxs-lookup"><span data-stu-id="c6158-308">You can also implement transactional logic across all items belonging to a tenant.</span></span> <span data-ttu-id="c6158-309">Because multiple tenants share a container, you can better utilize storage and provisioned throughput by pooling resources for all tenants within a single container rather than provisioning for each tenant.</span><span class="sxs-lookup"><span data-stu-id="c6158-309">Because multiple tenants share a container, you can better utilize storage and provisioned throughput by pooling resources for all tenants within a single container rather than provisioning for each tenant.</span></span> <span data-ttu-id="c6158-310">The drawback is that you don't have performance isolation per tenant.</span><span class="sxs-lookup"><span data-stu-id="c6158-310">The drawback is that you don't have performance isolation per tenant.</span></span> <span data-ttu-id="c6158-311">Increasing throughput to guarantee performance will apply to the entire container with all the tenants versus targeted increases for an individual tenant.</span><span class="sxs-lookup"><span data-stu-id="c6158-311">Increasing throughput to guarantee performance will apply to the entire container with all the tenants versus targeted increases for an individual tenant.</span></span>
* <span data-ttu-id="c6158-312">**One container per tenant**.</span><span class="sxs-lookup"><span data-stu-id="c6158-312">**One container per tenant**.</span></span> <span data-ttu-id="c6158-313">In this model, each tenant has its own container, and you can reserve throughput with guaranteed performance per tenant.</span><span class="sxs-lookup"><span data-stu-id="c6158-313">In this model, each tenant has its own container, and you can reserve throughput with guaranteed performance per tenant.</span></span> <span data-ttu-id="c6158-314">This model is more cost-effective for multitenant applications with a few tenants.</span><span class="sxs-lookup"><span data-stu-id="c6158-314">This model is more cost-effective for multitenant applications with a few tenants.</span></span>

<span data-ttu-id="c6158-315">You can also use a hybrid approach that colocates small tenants together and isolates larger tenants to their own containers.</span><span class="sxs-lookup"><span data-stu-id="c6158-315">You can also use a hybrid approach that colocates small tenants together and isolates larger tenants to their own containers.</span></span>

## <a name="next-steps"></a><span data-ttu-id="c6158-316">Next steps</span><span class="sxs-lookup"><span data-stu-id="c6158-316">Next steps</span></span>
<span data-ttu-id="c6158-317">In this article, we provided an overview of concepts and best practices for scaling and partitioning in Azure Cosmos DB.</span><span class="sxs-lookup"><span data-stu-id="c6158-317">In this article, we provided an overview of concepts and best practices for scaling and partitioning in Azure Cosmos DB.</span></span> 

* <span data-ttu-id="c6158-318">Learn about [provisioned throughput in Azure Cosmos DB](request-units.md).</span><span class="sxs-lookup"><span data-stu-id="c6158-318">Learn about [provisioned throughput in Azure Cosmos DB](request-units.md).</span></span>
* <span data-ttu-id="c6158-319">Learn about [global distribution in Azure Cosmos DB](distribute-data-globally.md).</span><span class="sxs-lookup"><span data-stu-id="c6158-319">Learn about [global distribution in Azure Cosmos DB](distribute-data-globally.md).</span></span>



